//all buffer overflows
.decl buffer_overflow(instructionid: _instructionid, level: symbol, message: symbol)
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_strncpy_call_instruction(IID, LEVEL, MESSAGE).
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_fgets_call_instruction(IID, LEVEL, MESSAGE).
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_snprintf_call_instruction(IID, LEVEL, MESSAGE).
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_sprintf_call_instruction(IID, LEVEL, MESSAGE).
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_memcpy_call_instruction(IID, LEVEL, MESSAGE).
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_memmove_call_instruction(IID, LEVEL, MESSAGE).
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_strcpy_call_instruction(IID, LEVEL, MESSAGE).
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_wscpy_call_instruction(IID, LEVEL, MESSAGE).
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_strcat_call_instruction(IID, LEVEL, MESSAGE).
buffer_overflow(IID, LEVEL, MESSAGE) :- is_vulnerable_strncat_call_instruction(IID, LEVEL, MESSAGE).

//strncpy vulnerable to bo
.decl is_vulnerable_strncpy_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)
is_vulnerable_strncpy_call_instruction(IID, LEVEL, MESSAGE) :- is_strncpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, OV1), get_third_operand(IID, N), 
get_buffsize_by_vreg(DEST_SIZE, FID, OV1), 
get_int_by_vreg(COPY_SIZE, FID, N),
MESSAGE = cat(cat(cat("strncpy: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), to_string(COPY_SIZE)),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < COPY_SIZE.

//fgets vulnerable to bo
.decl is_vulnerable_fgets_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)
is_vulnerable_fgets_call_instruction(IID, LEVEL, MESSAGE) :- 
is_fgets_call_instruction(IID), block(FID, BID, _), instruction(BID, IID, _, _), 
get_first_operand(IID, OV1), get_second_operand(IID, N),
get_buffsize_by_vreg(DEST_SIZE, FID, OV1), 
get_int_by_vreg(COPY_SIZE, FID, N),
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < COPY_SIZE,
MESSAGE = cat(cat(cat("fgets: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), N),
LEVEL = "Vulnerability".

//snprintf vulnerable to bo
.decl is_vulnerable_snprintf_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)
is_vulnerable_snprintf_call_instruction(IID, LEVEL, MESSAGE) :- 
is_X_call_instruction("snprintf", IID),
block(FID, BID, _), instruction(BID, IID, _, _), 
get_first_operand(IID, DEST), 
get_second_operand(IID, N),
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_int_by_vreg(COPY_SIZE, FID, N),
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < COPY_SIZE,
LEVEL = "Vulnerability",
MESSAGE = cat(cat(cat("snprintf: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), N)
.


//sprintf vulnerable to bo
.decl is_vulnerable_sprintf_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)
//.output is_vulnerable_sprintf_call_instruction
//case simple %str
is_vulnerable_sprintf_call_instruction(IID, LEVEL, MESSAGE) :- 
is_X_call_instruction("sprintf", IID),
block(FID, BID, _), instruction(BID, IID, _, _), 
get_first_operand(IID, DEST), 
get_third_operand(IID, SRC),
get_second_operand(IID, FORMATSTR_GEP),
instruction(_, IID_GEP, FORMATSTR_GEP, "getelementptr"),
get_first_operand(IID_GEP, FORMATSTR_GLOB),
is_global(FORMATSTR_GLOB),
get_global_str_value(FORMATSTR, FORMATSTR_GLOB),
FORMATSTR = "%s\00",
get_buffsize_by_vreg(SRC_SIZE, FID, SRC),
get_buffsize_by_vreg(DEST_SIZE, FID, DEST),
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < SRC_SIZE,
LEVEL = "Vulnerability",
MESSAGE = cat(cat(cat("sprintf(dest %s src): possible insufficient buffer size ", to_string(DEST_SIZE)), " for source of size "), to_string(SRC_SIZE))

.


//memcpy vulnerable to bo
.decl is_vulnerable_memcpy_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)
//case default (char array)
is_vulnerable_memcpy_call_instruction(IID, LEVEL, MESSAGE) :- is_memcpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), get_third_operand(IID, N),
instruction(_, _, DEST, OPCDESTTYPE),
OPCDESTTYPE != "bitcast",
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_int_by_vreg(COPY_SIZE, FID, N),
MESSAGE = cat(cat(cat("memcpy: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), to_string(COPY_SIZE)),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < COPY_SIZE.

//case int array
is_vulnerable_memcpy_call_instruction(IID, LEVEL, MESSAGE) :- 
is_memcpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), 
instruction(_, IIDDEST, DEST, OPCDESTTYPE),
OPCDESTTYPE = "bitcast",
get_first_operand(IIDDEST, DEST_ORIGIN),
memlocation(FID, DEST_ORIGIN, "i32*", _),
get_third_operand(IID, N), 
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_int_by_vreg(COPY_SIZE_FULL, FID, N),
COPY_SIZE = COPY_SIZE_FULL/4,
MESSAGE = cat(cat(cat("memcpy: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), to_string(COPY_SIZE)),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < COPY_SIZE.

//case int64 array
is_vulnerable_memcpy_call_instruction(IID, LEVEL, MESSAGE) :- 
is_memcpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), 
instruction(_, IIDDEST, DEST, OPCDESTTYPE),
OPCDESTTYPE = "bitcast",
get_first_operand(IIDDEST, DEST_ORIGIN),
memlocation(FID, DEST_ORIGIN, "i64*", _),
get_third_operand(IID, N), 
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_int_by_vreg(COPY_SIZE_FULL, FID, N),
COPY_SIZE = COPY_SIZE_FULL/8,
MESSAGE = cat(cat(cat("memcpy: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), to_string(COPY_SIZE)),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < COPY_SIZE.

//memmove vulnerable to bo
.decl is_vulnerable_memmove_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)

//case default (char array)
is_vulnerable_memmove_call_instruction(IID, LEVEL, MESSAGE) :- is_memmove_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), get_third_operand(IID, N), 
instruction(_, _, DEST, OPCDESTTYPE),
OPCDESTTYPE != "bitcast",
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_int_by_vreg(COPY_SIZE, FID, N),
MESSAGE = cat(cat(cat("memmove: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), to_string(COPY_SIZE)),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < COPY_SIZE.

//case int array
is_vulnerable_memmove_call_instruction(IID, LEVEL, MESSAGE) :- is_memmove_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), get_third_operand(IID, N),
instruction(_, IIDDEST, DEST, OPCDESTTYPE),
OPCDESTTYPE = "bitcast",
get_first_operand(IIDDEST, DEST_ORIGIN),
memlocation(FID, DEST_ORIGIN, "i32*", _), 
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_int_by_vreg(COPY_SIZE_FULL, FID, N),
COPY_SIZE = COPY_SIZE_FULL/4,
MESSAGE = cat(cat(cat("memmove: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), to_string(COPY_SIZE)),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < COPY_SIZE.

//case int64 array
is_vulnerable_memmove_call_instruction(IID, LEVEL, MESSAGE) :- is_memmove_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), get_third_operand(IID, N),
instruction(_, IIDDEST, DEST, OPCDESTTYPE),
OPCDESTTYPE = "bitcast",
get_first_operand(IIDDEST, DEST_ORIGIN),
memlocation(FID, DEST_ORIGIN, "i64*", _), 
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_int_by_vreg(COPY_SIZE_FULL, FID, N),
COPY_SIZE = COPY_SIZE_FULL/8,
MESSAGE = cat(cat(cat("memmove: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), to_string(COPY_SIZE)),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < COPY_SIZE.

//strcpy vulnerable to bo
.decl is_vulnerable_strcpy_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)
is_vulnerable_strcpy_call_instruction(IID, LEVEL, MESSAGE) :- is_strcpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), get_second_operand(IID, SRC), 
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_buffsize_by_vreg(SRC_SIZE, FID, SRC),
MESSAGE = cat(cat(cat(cat("strcpy: possible insufficient buffer size ", to_string(DEST_SIZE)), " for copy of "), to_string(SRC_SIZE)), " sized buffer"),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < SRC_SIZE.

//wscpy vulnerable to bo
.decl is_vulnerable_wscpy_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)
is_vulnerable_wscpy_call_instruction(IID, LEVEL, MESSAGE) :- is_wscpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), get_second_operand(IID, SRC), 
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_buffsize_by_vreg(SRC_SIZE, FID, SRC),
MESSAGE = cat(cat(cat(cat("wscpy: possible insufficient buffer size ", to_string(DEST_SIZE)), " for copy of "), to_string(SRC_SIZE)), " sized buffer"),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < SRC_SIZE.

//strcat vulnerable to bo
//length of source content unknown
.decl is_vulnerable_strcat_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)
is_vulnerable_strcat_call_instruction(IID, LEVEL, MESSAGE) :- is_X_call_instruction("strcat", IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), get_second_operand(IID, SRC), 
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_buffsize_by_vreg(SRC_SIZE, FID, SRC),
MESSAGE = cat(cat(cat(cat("strcat: possible insufficient buffer size ", to_string(DEST_SIZE)), " for concatenation with "), to_string(SRC_SIZE)), " sized buffer"),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE < SRC_SIZE.

//strncat vulnerable to bo
//length of source content unknown
.decl is_vulnerable_strncat_call_instruction(instructionid: _instructionid, level: symbol, message: symbol)
is_vulnerable_strncat_call_instruction(IID, LEVEL, MESSAGE) :- is_X_call_instruction("strncat", IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, DEST), get_third_operand(IID, N), 
get_buffsize_by_vreg(DEST_SIZE, FID, DEST), 
get_int_by_vreg(CAT_SIZE, FID, N),
MESSAGE = cat(cat(cat(cat("strncat: possible insufficient buffer size ", to_string(DEST_SIZE)), " for concatenation with "), to_string(CAT_SIZE)), ", plus null-character characters"),
LEVEL = "Vulnerability",
DEST_SIZE !=1, DEST_SIZE !=0,//this eliminates many false positives
DEST_SIZE <= CAT_SIZE.




/*

get_buffsize_by_vreg(DEST_SIZE, FID, DEST),



MESSAGE = cat(cat(cat("sprintf: possible insufficient buffer size ", to_string(DEST_SIZE)), " for n of size "), TOTALSIZE),
DEST_SIZE < COPY_SIZE.



.decl get_length_of_unformatted_str(length: number, str: symbol)
get_length_of_unformatted_str(LEN, STR) :-
CLEANSTR = STR
//This probably need a CPP implementation

*/
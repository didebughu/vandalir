//operands access

.decl get_first_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_first_operand(delimeter=",")
get_first_operand(IID, VAL) :- 
operand(IID, OID1, OV1), 
!operand(IID, OID1-1, _), VAL = OV1.

.decl get_second_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_second_operand(delimeter=",")
get_second_operand(IID, VAL) :- 
operand(IID, OID1, _), operand(IID, OID2, OV2),
!operand(IID, OID1-1, _), OID2=OID1+1, VAL = OV2.

.decl get_third_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_third_operand(delimeter=",")
get_third_operand(IID, VAL) :- 
operand(IID, OID1, _), operand(IID, OID2, _), operand(IID, OID3, OV3),
!operand(IID, OID1-1, _), OID2=OID1+1, OID3=OID2+1, VAL = OV3.

.decl get_fourth_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_fourth_operand(delimeter=",")
get_fourth_operand(IID, VAL) :- 
operand(IID, OID1, _), operand(IID, OID2, _), operand(IID, OID3, _), operand(IID, OID4, OV4),
!operand(IID, OID1-1, _), OID2=OID1+1, OID3=OID2+1, OID4=OID3+1, VAL = OV4.

.decl get_fifth_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_fifth_operand(delimeter=",")
get_fifth_operand(IID, VAL) :- 
operand(IID, OID1, _), operand(IID, OID2, _), operand(IID, OID3, _), operand(IID, OID4, _), operand(IID, OID5, OV5),
!operand(IID, OID1-1, _), OID2=OID1+1, OID3=OID2+1, OID4=OID3+1, OID5=OID4+1, VAL = OV5.

//get ith operand
.decl get_ith_operand(instructionid: _instructionid, i: number, operandvalue: symbol)
get_ith_operand(IID, I, VAL) :- I=1, get_first_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I=2, get_second_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I=3, get_third_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I=4, get_fourth_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I=5, get_fifth_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I>5, get_ith_operand_recursive(IID, _, I, VAL).

//recursive helper
.decl get_ith_operand_recursive(instructionid: _instructionid, operandid: _operandid, i: number, operandvalue: symbol)
get_ith_operand_recursive(IID, OID, I, VAL) :- I=1, operand(IID, OID, VAL), !operand(IID, OID-1, _).
get_ith_operand_recursive(IID, OID, I, VAL) :- I>1, I=I2+1, operand(IID, OID, VAL), get_ith_operand_recursive(IID, OID-1, I2, _).

//get last operand
.decl get_last_operand(instructionid: _instructionid, operandvalue: symbol)
get_last_operand(IID, OV) :- 
operand(IID, OID, OV), !operand(IID, OID+1, _).

//number of operands
.decl get_num_operands(instructionid: _instructionid, operandscount: number)
//.output get_num_operands(delimeter=",")
get_num_operands(IID, COUNT) :- operand(IID, OID, _), !operand(IID, OID2, _), OID2 = OID-1, 
get_num_operands_recursive(IID, OID, COUNT).

//recursive
.decl get_num_operands_recursive(instructionid: _instructionid, operandid: _operandid, operandscount: number)
get_num_operands_recursive(IID, OID, COUNT) :- operand(IID, OID, _), !operand(IID, OID2, _), 
OID2 = OID+1, COUNT=1.
get_num_operands_recursive(IID, OID, COUNT) :- operand(IID, OID, _), operand(IID, OID2, _), 
OID2 = OID+1, get_num_operands_recursive(IID, OID2, OLDCOUNT), COUNT = OLDCOUNT+1.

//get only conversion instruction
.decl is_conversion_instruction(instructionid: _instructionid)
is_conversion_instruction(IID) :- instruction(_, IID, _, OPC), conversion_instruction(OPC).

.decl conversion_instruction(opcode: symbol)
conversion_instruction(OPC) :- OPC = "trunc".
conversion_instruction(OPC) :- OPC = "zext".
conversion_instruction(OPC) :- OPC = "sext".
conversion_instruction(OPC) :- OPC = "fptrunc".
conversion_instruction(OPC) :- OPC = "fpext".
conversion_instruction(OPC) :- OPC = "fptoui".
conversion_instruction(OPC) :- OPC = "fptosi".
conversion_instruction(OPC) :- OPC = "uitofp".
conversion_instruction(OPC) :- OPC = "sitofp".
conversion_instruction(OPC) :- OPC = "ptrtoint".
conversion_instruction(OPC) :- OPC = "inttoptr".
conversion_instruction(OPC) :- OPC = "bitcast".
conversion_instruction(OPC) :- OPC = "addrspacecast".

//get only call instruction
.decl is_call_instruction(instructionid: _instructionid)
is_call_instruction(IID) :- instruction(_, IID, _, OPC), OPC = "call".

//get only call strncpy instructions
.decl is_strncpy_call_instruction(instructionid: _instructionid)
is_strncpy_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "strncpy".

//get only call strlen instructions
.decl is_strlen_call_instruction(instructionid: _instructionid)
is_strlen_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "strlen".

//get only call fgets instructions
.decl is_fgets_call_instruction(instructionid: _instructionid)
is_fgets_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "fgets".

//get only call malloc instructions
.decl is_malloc_call_instruction(instructionid: _instructionid)
is_malloc_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "malloc".

//get only call calloc instructions
.decl is_calloc_call_instruction(instructionid: _instructionid)
is_calloc_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "calloc".

//get only call realloc instructions
.decl is_realloc_call_instruction(instructionid: _instructionid)
is_realloc_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "realloc".

//if call instruction give called function name
.decl get_function_for_call_instruction(functionname: symbol, instructionid: _instructionid)
//a call instruction
get_function_for_call_instruction(NAME, IID) :- is_call_instruction(IID),
get_last_operand(IID, NAME).


.decl get_fid_for_call_instruction(functionid: _functionid, instructionid: _instructionid)
//.output get_fid_for_call_instruction(delimiter=",")
get_fid_for_call_instruction(FID, IID) :- get_function_for_call_instruction(FNAME, IID), get_fid_by_fname(FID, FNAME).


.decl get_fid_by_fname(functionid: _functionid, fname: symbol)
get_fid_by_fname(FID, FNAME) :- function(FID, FNAME, _, _).


//get size of alloca
.decl get_size_of_alloca(instructionid: _instructionid, size: number)
get_size_of_alloca(IID, SIZE) :- instruction(_, IID, _, OPC), OPC = "alloca",
get_second_operand(IID, OV1),
SIZE = to_number(OV1).

.decl is_alloca_multidimensional(instructionid: _instructionid)
is_alloca_multidimensional(IID) :- instruction(_, IID, _, OPC), OPC = "alloca",
get_num_operands(IID, OPCOUNT), OPCOUNT>2.

.decl get_alloca_arraylevel(instructionid: _instructionid, arraylevel: number)
//.output get_alloca_arraylevel(delimiter=";")
get_alloca_arraylevel(IID, SIZE) :- instruction(_, IID, _, OPC), OPC = "alloca",
get_num_operands(IID, OPCOUNT), SIZE = OPCOUNT-1.

//heap

//get only heap allocation calls
.decl is_heap_allocation_call(instructionid: _instructionid)
is_heap_allocation_call(IID) :- 
is_call_instruction(IID), get_function_for_call_instruction(FNAME, IID),
heap_allocation_instruction(FNAME).

.decl heap_allocation_instruction(instruction: symbol)
heap_allocation_instruction(INS) :- INS = "malloc".
heap_allocation_instruction(INS) :- INS = "calloc".
heap_allocation_instruction(INS) :- INS = "realloc".
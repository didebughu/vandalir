//operands access

.decl get_first_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_first_operand(delimeter=",")
get_first_operand(IID, VAL) :- 
operand(IID, OID1, OV1), 
!operand(IID, OID1-1, _), VAL = OV1.

.decl get_second_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_second_operand(delimeter=",")
get_second_operand(IID, VAL) :- 
operand(IID, OID1, _), operand(IID, OID2, OV2),
!operand(IID, OID1-1, _), OID2=OID1+1, VAL = OV2.

.decl get_third_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_third_operand(delimeter=",")
get_third_operand(IID, VAL) :- 
operand(IID, OID1, _), operand(IID, OID2, _), operand(IID, OID3, OV3),
!operand(IID, OID1-1, _), OID2=OID1+1, OID3=OID2+1, VAL = OV3.

.decl get_fourth_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_fourth_operand(delimeter=",")
get_fourth_operand(IID, VAL) :- 
operand(IID, OID1, _), operand(IID, OID2, _), operand(IID, OID3, _), operand(IID, OID4, OV4),
!operand(IID, OID1-1, _), OID2=OID1+1, OID3=OID2+1, OID4=OID3+1, VAL = OV4.

.decl get_fifth_operand(instructionid: _instructionid, operandvalue: symbol)
//.output get_fifth_operand(delimeter=",")
get_fifth_operand(IID, VAL) :- 
operand(IID, OID1, _), operand(IID, OID2, _), operand(IID, OID3, _), operand(IID, OID4, _), operand(IID, OID5, OV5),
!operand(IID, OID1-1, _), OID2=OID1+1, OID3=OID2+1, OID4=OID3+1, OID5=OID4+1, VAL = OV5.

//get ith operand
.decl get_ith_operand(instructionid: _instructionid, i: number, operandvalue: symbol)
get_ith_operand(IID, I, VAL) :- I=1, get_first_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I=2, get_second_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I=3, get_third_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I=4, get_fourth_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I=5, get_fifth_operand(IID, VAL).
get_ith_operand(IID, I, VAL) :- I>5, get_ith_operand_recursive(IID, _, I, VAL).

//recursive helper
.decl get_ith_operand_recursive(instructionid: _instructionid, operandid: _operandid, i: number, operandvalue: symbol)
get_ith_operand_recursive(IID, OID, I, VAL) :- I=1, operand(IID, OID, OV1), !operand(IID, OID-1, _), VAL = OV1.
get_ith_operand_recursive(IID, OID, I, VAL) :- I>1, I=I2+1, operand(IID, OID, VAL), get_ith_operand_recursive(IID, OID-1, I2, _).

//get last operand
.decl get_last_operand(instructionid: _instructionid, operandvalue: symbol)
get_last_operand(IID, OV) :- 
operand(IID, OID, OV), !operand(IID, OID+1, _).

//number of operands
.decl get_num_operands(instructionid: _instructionid, operandscount: number)
//.output get_num_operands(delimeter=",")
get_num_operands(IID, COUNT) :- operand(IID, OID, _), !operand(IID, OID2, _), OID2 = OID-1, 
get_num_operands_recursive(IID, OID, COUNT).

//recursive
.decl get_num_operands_recursive(instructionid: _instructionid, operandid: _operandid, operandscount: number)
get_num_operands_recursive(IID, OID, COUNT) :- operand(IID, OID, _), !operand(IID, OID2, _), 
OID2 = OID+1, COUNT=1.
get_num_operands_recursive(IID, OID, COUNT) :- operand(IID, OID, _), operand(IID, OID2, _), 
OID2 = OID+1, get_num_operands_recursive(IID, OID2, OLDCOUNT), COUNT = OLDCOUNT+1.

//get only conversion instruction
.decl is_conversion_instruction(instructionid: _instructionid)
is_conversion_instruction(IID) :- instruction(_, IID, _, OPC), conversion_instruction(OPC).

.decl conversion_instruction(opcode: symbol)
conversion_instruction(OPC) :- OPC = "trunc".
conversion_instruction(OPC) :- OPC = "zext".
conversion_instruction(OPC) :- OPC = "sext".
conversion_instruction(OPC) :- OPC = "fptrunc".
conversion_instruction(OPC) :- OPC = "fpext".
conversion_instruction(OPC) :- OPC = "fptoui".
conversion_instruction(OPC) :- OPC = "fptosi".
conversion_instruction(OPC) :- OPC = "uitofp".
conversion_instruction(OPC) :- OPC = "sitofp".
conversion_instruction(OPC) :- OPC = "ptrtoint".
conversion_instruction(OPC) :- OPC = "inttoptr".
conversion_instruction(OPC) :- OPC = "bitcast".
conversion_instruction(OPC) :- OPC = "addrspacecast".

//get only call instruction
.decl is_call_instruction(instructionid: _instructionid)
is_call_instruction(IID) :- instruction(_, IID, _, OPC), OPC = "call".

//get only call strncpy instructions
.decl is_strncpy_call_instruction(instructionid: _instructionid)
is_strncpy_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "strncpy".

//get only call strlen instructions
.decl is_strlen_call_instruction(instructionid: _instructionid)
is_strlen_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "strlen".

//get only call fgets instructions
.decl is_fgets_call_instruction(instructionid: _instructionid)
is_fgets_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "fgets".

//get only call malloc instructions
.decl is_malloc_call_instruction(instructionid: _instructionid)
is_malloc_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "malloc".

//get only call calloc instructions
.decl is_calloc_call_instruction(instructionid: _instructionid)
is_calloc_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "calloc".

//get only call realloc instructions
.decl is_realloc_call_instruction(instructionid: _instructionid)
is_realloc_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "realloc".

//if call instruction give called function name
.decl get_function_for_call_instruction(functionname: symbol, instructionid: _instructionid)
//a call instruction
get_function_for_call_instruction(NAME, IID) :- is_call_instruction(IID),
get_last_operand(IID, NAME).


.decl get_fid_for_call_instruction(functionid: _functionid, instructionid: _instructionid)
//.output get_fid_for_call_instruction(delimiter=",")
get_fid_for_call_instruction(FID, IID) :- get_function_for_call_instruction(FNAME, IID), get_fid_by_fname(FID, FNAME).


.decl get_fid_by_fname(functionid: _functionid, fname: symbol)
get_fid_by_fname(FID, FNAME) :- function(FID, FNAME, _, _).


//get size of alloca
.decl get_size_of_alloca(instructionid: _instructionid, size: number)
get_size_of_alloca(IID, SIZE) :- instruction(_, IID, _, OPC), OPC = "alloca",
get_first_operand(IID, OV1),
SIZE = to_number(OV1).


//heap

//get only heap allocation calls
.decl is_heap_allocation_call(instructionid: _instructionid)
is_heap_allocation_call(IID) :- 
is_call_instruction(IID), get_function_for_call_instruction(FNAME, IID),
heap_allocation_instruction(FNAME).

.decl heap_allocation_instruction(instruction: symbol)
heap_allocation_instruction(INS) :- INS = "malloc".
heap_allocation_instruction(INS) :- INS = "calloc".
heap_allocation_instruction(INS) :- INS = "realloc".


//operand instructions

//is given operand a vreg
.decl is_vreg(type: symbol)
is_vreg(T) :- contains("%", T), opval(T),
SUBSTR = substr(T, 1, strlen(T)), !contains("%", SUBSTR).

//is given operand a pointer
.decl is_pointer(type: symbol)
is_pointer(T) :- pointer_level(T, LVL), LVL > 0.

.decl is_numeric(type: symbol)
is_numeric(VAL) :- opval(VAL), 
!contains(":", VAL), !contains("%", VAL), !contains("[", VAL), !contains("]", VAL),
!contains("(", VAL), !contains(")", VAL), !contains("'", VAL), !contains(" ", VAL),
!contains("a", VAL), !contains("b", VAL), !contains("c", VAL), !contains("d", VAL), 
!contains("e", VAL), !contains("f", VAL), !contains("g", VAL), !contains("h", VAL), 
!contains("i", VAL), !contains("j", VAL), !contains("k", VAL), !contains("l", VAL), 
!contains("m", VAL), !contains("n", VAL), !contains("o", VAL), !contains("p", VAL), 
!contains("q", VAL), !contains("r", VAL), !contains("s", VAL), !contains("t", VAL), 
!contains("u", VAL), !contains("v", VAL), !contains("w", VAL), !contains("x", VAL), 
!contains("y", VAL), !contains("z", VAL), !contains("A", VAL), !contains("B", VAL), 
!contains("C", VAL), !contains("D", VAL), !contains("E", VAL), !contains("F", VAL), 
!contains("G", VAL), !contains("H", VAL), !contains("I", VAL), !contains("J", VAL), 
!contains("K", VAL), !contains("L", VAL), !contains("M", VAL), !contains("N", VAL), 
!contains("O", VAL), !contains("P", VAL), !contains("Q", VAL), !contains("R", VAL), 
!contains("S", VAL), !contains("T", VAL), !contains("U", VAL), !contains("V", VAL), 
!contains("W", VAL), !contains("X", VAL), !contains("Y", VAL), !contains("Z", VAL). 

//get level of pointer (or pointer to pointer, etc.)
.decl pointer_level(type: symbol, level: number)
//.output pointer_level(delimiter=",")
pointer_level(TYPE, LVL) :- type(TYPE), !contains("*", TYPE), LVL = 0.
pointer_level(TYPE, LVL) :- type(TYPE), contains("*", TYPE), LVL=OLDLVL+1, 
SUBSTR = substr(TYPE, 0, strlen(TYPE)-1),
pointer_level(SUBSTR, OLDLVL).

.type _instruction = [
	blockid: _blockid, 
	instructionid: _instructionid, 
	virtualregister: _vreg,
	opcode: symbol,
	operandlist: _operandNode
]

.type _operandNode = [
	instructionid: _instructionid,
	operandid: _operandid,
	operandvalue: symbol,
	next: _operandNode
]


//init data structures

.decl init_instruction(instruction: _instruction)
//case more than one operand
init_instruction(INS) :- 
INS = [BID, IID, VREG, OPC, OL],
instruction(BID, IID, VREG, OPC),
init_operandList(OL),
OL = [IID, OID, OV, NEXT], OID2 = OID-1, !operand(IID, OID2, _), operand(IID, OID, OV), init_operandList(NEXT).
//case just one operand
init_instruction(INS) :- 
INS = [BID, IID, VREG, OPC, OL],
instruction(BID, IID, VREG, OPC),
init_operandList(OL),
OL = [IID, OID, OV, nil], OID2 = OID-1, !operand(IID, OID2, _), operand(IID, OID, OV).

.decl init_operandList(operandNode: _operandNode)
//case last operand
init_operandList(OPN) :- operand(IID, OID, OV),
OPN = [IID, OID, OV, nil], !operand(IID, OID+1, _).
//case not last operand, !nil
init_operandList(OPN) :- operand(IID, OID, OV), OID2 = OID+1, operand(IID, OID2, OV2),
OPN = [IID, OID, OV, NEXT], init_operandList(NEXT), NEXT = [IID, OID2, OV2, NEXTNEXT], init_operandList(NEXTNEXT).
//case not last operand, nil
init_operandList(OPN) :- operand(IID, OID, OV), OID2 = OID+1, operand(IID, OID2, OV2),
OPN = [IID, OID, OV, NEXT], init_operandList(NEXT), NEXT = [IID, OID2, OV2, nil].


//operands access

.decl get_first_operand(instructionid: _instructionid, operandvalue: symbol)
get_first_operand(IID, OV) :- init_instruction(INS), 
INS = [_, IID, _, _, OL],
OL = [_, _, OV, _].

.decl get_second_operand(instructionid: _instructionid, operandvalue: symbol)
get_second_operand(IID, OV) :- init_instruction(INS), 
INS = [_, IID, _, _, OL],
OL = [_, _, _, SECOND],
SECOND = [_, _, OV, _].

.decl get_third_operand(instructionid: _instructionid, operandvalue: symbol)
get_third_operand(IID, OV) :- init_instruction(INS), 
INS = [_, IID, _, _, OL],
OL = [_, _, _, SECOND],
SECOND = [_, _, _, THIRD],
THIRD = [_, _, OV, _].

.decl get_fourth_operand(instructionid: _instructionid, operandvalue: symbol)
get_fourth_operand(IID, OV) :- init_instruction(INS), 
INS = [_, IID, _, _, OL],
OL = [_, _, _, SECOND],
SECOND = [_, _, _, THIRD],
THIRD = [_, _, _, FOURTH],
FOURTH = [_, _, OV, _].

.decl get_last_operand(instructionid: _instructionid, operandvalue: symbol)
get_last_operand(IID, OV) :- init_operandList(OL),
OL = [IID, OID, OV, NEXT], NEXT = nil, operand(IID, OID, OV).

//number of operands
.decl get_num_operands(instructionid: _instructionid, operandscount: number)
get_num_operands(IID, COUNT) :- operand(IID, OID, _), !operand(IID, OID2, _), OID2 = OID-1, 
get_num_operands_recursive(IID, OID, COUNT).

//recursive
.decl get_num_operands_recursive(instructionid: _instructionid, operandid: _operandid, operandscount: number)
get_num_operands_recursive(IID, OID, COUNT) :- operand(IID, OID, _), !operand(IID, OID2, _), 
OID2 = OID+1, COUNT=1.
get_num_operands_recursive(IID, OID, COUNT) :- operand(IID, OID, _), operand(IID, OID2, _), 
OID2 = OID+1, get_num_operands_recursive(IID, OID2, OLDCOUNT), COUNT = OLDCOUNT+1.

//get only conversion instruction
.decl is_conversion_instruction(instructionid: _instructionid)
is_conversion_instruction(IID) :- instruction(_, IID, _, OPC), conversion_instruction(OPC).

.decl conversion_instruction(opcode: symbol)
conversion_instruction(OPC) :- OPC = "trunc".
conversion_instruction(OPC) :- OPC = "zext".
conversion_instruction(OPC) :- OPC = "sext".
conversion_instruction(OPC) :- OPC = "fptrunc".
conversion_instruction(OPC) :- OPC = "fpext".
conversion_instruction(OPC) :- OPC = "fptoui".
conversion_instruction(OPC) :- OPC = "fptosi".
conversion_instruction(OPC) :- OPC = "uitofp".
conversion_instruction(OPC) :- OPC = "sitofp".
conversion_instruction(OPC) :- OPC = "ptrtoint".
conversion_instruction(OPC) :- OPC = "inttoptr".
conversion_instruction(OPC) :- OPC = "bitcast".
conversion_instruction(OPC) :- OPC = "addrspacecast".

//get only call instruction
.decl is_call_instruction(instructionid: _instructionid)
is_call_instruction(IID) :- instruction(_, IID, _, OPC), OPC = "call".

//get only call strncpy instructions
.decl is_strncpy_call_instruction(instructionid: _instructionid)
is_strncpy_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "strncpy".

//get only call strlen instructions
.decl is_strlen_call_instruction(instructionid: _instructionid)
is_strlen_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "strlen".

//get only call fgets instructions
.decl is_fgets_call_instruction(instructionid: _instructionid)
is_fgets_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "fgets".

//get only call strlen instructions
.decl is_malloc_call_instruction(instructionid: _instructionid)
is_malloc_call_instruction(IID) :- is_call_instruction(IID), get_last_operand(IID, OV), OV = "malloc".

//if call instruction give called function name
.decl get_function_for_call_instruction(functionname: symbol, instructionid: _instructionid)
//case not a call instruction
get_function_for_call_instruction(OPC, IID) :- instruction(_, IID, _, OPC), OPC != "call".
//a call instruction
get_function_for_call_instruction(NAME, IID) :- instruction(_, IID, _, OPC), OPC = "call",
MAXID = max OID : {operand(IID, OID, _) }, operand(IID, MAXID, NAME).

//get size of alloca
.decl get_size_of_alloca(instructionid: _instructionid, size: number)
get_size_of_alloca(IID, SIZE) :- instruction(_, IID, _, OPC), OPC = "alloca",
get_first_operand(IID, OV1),
SIZE = to_number(OV1).

//get size of malloc
.decl get_size_of_malloc(instructionid: _instructionid, size: number)
get_size_of_malloc(IID, SIZE) :- is_malloc_call_instruction(IID),
get_first_operand(IID, OV1),
SIZE = to_number(OV1).

//operand instructions


//is given operand a pointer
.decl is_pointer(type: symbol)
is_pointer(T) :- pointer_level(T, LVL), LVL > 0.


//get level of pointer (or pointer to pointer, etc.)
.decl pointer_level(type: symbol, level: number)
.output pointer_level(delimiter=",")
pointer_level(TYPE, LVL) :- type(TYPE), !contains("*", TYPE), LVL = 0.
pointer_level(TYPE, LVL) :- type(TYPE), contains("*", TYPE), LVL=OLDLVL+1, 
SUBSTR = substr(TYPE, 0, strlen(TYPE)-1),
pointer_level(SUBSTR, OLDLVL).

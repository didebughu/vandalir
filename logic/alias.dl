//find equal memory location (alias analysis)
.decl memequals(functionid1: _functionid, memlocation1: symbol, memtyp1: symbol, memcategory1: _memcategory, 
functionid2: _functionid, memlocation2: symbol, memtyp2: symbol, memcategory2: _memcategory)
//.output memequals(delimiter=",")

//case: (a <==> b) ==> (b <==> a)
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :- 
memequals(FID2, LOC2, TYPE2, CAT2, FID1, LOC1, TYPE1, CAT1).

//case points-to: (x -> a && x -> b) ==> (a <==> b)
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :- 
points_to(PFID, PLOC, PTYPE, PCAT, FID1, LOC1, TYPE1, CAT1), 
points_to(PFID, PLOC, PTYPE, PCAT, FID2, LOC2, TYPE2, CAT2).

//case load pointer
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :-
memlocation(FID1, LOC1, TYPE1, CAT1), 
memlocation(FID2, LOC2, TYPE2, CAT2),
instruction(BID, IID, VREG, OPC), block(FID, BID, _), OPC = "load",
pointer_level(TYPE1, TYPE1_PLVL),
pointer_level(TYPE2, TYPE2_PLVL),
TYPE1_PLVL = TYPE2_PLVL,
TYPE1_PLVL > 0,
VREG = LOC1,
FID1 = FID,
FID2 = FID, 
get_third_operand(IID, LOADADDR), 
LOADADDR = LOC2.

//case store a pointer
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :- 
block(FID, BID, _),
instruction(BID, IID, _, OPC), OPC = "store",
get_second_operand(IID, LOC2),
get_fourth_operand(IID, LOC1),
memlocation(FID1, LOC1, TYPE1, CAT1), memlocation(FID2, LOC2, TYPE2, CAT2),
pointer_level(TYPE1, TYPE1_PLVL),
pointer_level(TYPE2, TYPE2_PLVL),
TYPE1_PLVL = TYPE2_PLVL,
FID1 = FID,
FID2 = FID.

//case conversion instruction
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :-
memlocation(FID1, LOC1, TYPE1, CAT1), 
memlocation(FID2, LOC2, TYPE2, CAT2),
instruction(BID, IID, VREG, _), block(FID, BID, _), 
is_conversion_instruction(IID),
get_first_operand(IID, VREG_ORIG),
LOC1 = VREG,
LOC2 = VREG_ORIG,
FID1 = FID,
FID2 = FID.

//case function return
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :-
memlocation(FID1, LOC1, TYPE1, CAT1), 
memlocation(FID2, LOC2, TYPE2, CAT2),
get_fid_for_call_instruction(FID, IID),
function(FID, _, _, RETTYPE),
get_ret_register(FID, VREG_RETVAL),
instruction(BID, IID, VREG, _), block(FID_CALL, BID, _),
LOC1 = VREG_RETVAL,
LOC2 = VREG,
TYPE1 = RETTYPE,
TYPE2 = RETTYPE,
memcategory(CAT1),
memcategory(CAT2),
FID1 = FID,
FID2 = FID_CALL.

//case function arguments
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :-
memlocation(FID1, LOC1, TYPE1, CAT1), 
memlocation(FID2, LOC2, TYPE2, CAT2),
get_call_argument_and_function_register(_, CFID, CARG, FID, VREG, ARGTYPE),
FID1 = CFID, LOC1=CARG, TYPE1 = ARGTYPE, memcategory(CAT1),
FID2 = FID, LOC2=VREG, TYPE1 =  ARGTYPE, memcategory(CAT2).


//from here on the cases for array handling

//first cases, where specific element of array could be located
//case getelementptr
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :-
memlocation(FID1, LOC1, TYPE1, CAT1), //LOC1 = GEP instruction
memlocation(FID2, LOC2, TYPE2, CAT2),
block(FID1, BID, _), 
FID1 = FID2, //equal functions
//TYPE1 = TYPE2, //TYPE1 gives the "basetype" of the GEP used for calculation. NOT the actual return type! 
instruction(BID, IID, LOC1, OPC), OPC = "getelementptr", //LOC 1 is GEP instruction
get_first_operand(IID, DATAOBJ), 
iterate_gep_indices(FID1, DATAOBJ, RESULTLOC, IID, _),
LOC2 = RESULTLOC.
//case getelementptr, MEMLOC2 is global
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :-
memlocation(FID1, LOC1, TYPE1, CAT1), //LOC1 = GEP instruction
memlocation(FID2, LOC2, TYPE2, CAT2),
block(FID1, BID, _), 
FID2 = -1, //FID2 can be -1 if global
//TYPE1 = TYPE2, //TYPE1 gives the "basetype" of the GEP used for calculation. NOT the actual return type! 
instruction(BID, IID, LOC1, OPC), OPC = "getelementptr", //LOC 1 is GEP instruction
get_first_operand(IID, DATAOBJ), 
iterate_gep_indices(FID1, DATAOBJ, RESULTLOC, IID, _),
LOC2 = RESULTLOC.



//help relations

//iterate through all indicies of gep instruction
.decl iterate_gep_indices(functionid: _functionid, startlocation: symbol, endlocation: symbol, instructionid: _instructionid, level: number)
//case maximum level reached
//.output iterate_gep_indices(delimiter=",")
iterate_gep_indices(FID, STARTLOC, RESULT, IID, LEVEL) :-
block(FID, BID, _), instruction(BID, IID, _, OPC), OPC = "getelementptr",
concatenated(FID, STARTLOC),
get_ith_operand(IID, LEVEL, NEWINDEX),
RESULT = cat(cat(STARTLOC, "."), NEWINDEX),
get_num_operands(IID, NUMOPERANDS),
LEVEL = NUMOPERANDS-1,
LEVEL > 1.
//case first level, index!=0
iterate_gep_indices(FID, STARTLOC, RESULT, IID, LEVEL) :-
block(FID, BID, _), instruction(BID, IID, _, OPC), OPC = "getelementptr",
concatenated(FID, STARTLOC),
get_ith_operand(IID, LEVEL, NEWINDEX),
NEWINDEX != to_string(0),
NEWSTARTLOC = cat(cat(STARTLOC, "."), NEWINDEX),
LEVEL = 2,
iterate_gep_indices(FID, NEWSTARTLOC, RESULT, IID, LEVEL+1).
//case first level, index=2
iterate_gep_indices(FID, STARTLOC, RESULT, IID, LEVEL) :-
block(FID, BID, _), instruction(BID, IID, _, OPC), OPC = "getelementptr",
concatenated(FID, STARTLOC),
get_ith_operand(IID, LEVEL, NEWINDEX),
NEWINDEX = to_string(0),
LEVEL = 2,
iterate_gep_indices(FID, STARTLOC, RESULT, IID, LEVEL+1).//skip this level if index = 2 (first level)
//case not final level reached, but also not the first level
iterate_gep_indices(FID, STARTLOC, RESULT, IID, LEVEL) :-
block(FID, BID, _), instruction(BID, IID, _, OPC), OPC = "getelementptr",
concatenated(FID, STARTLOC),
get_ith_operand(IID, LEVEL, NEWINDEX),
NEWSTARTLOC = cat(cat(STARTLOC, "."), NEWINDEX),
get_num_operands(IID, NUMOPERANDS),
LEVEL < NUMOPERANDS-1,
LEVEL > 2,
iterate_gep_indices(FID, NEWSTARTLOC, RESULT, IID, LEVEL+1).
//case memequals to get GEPs that do not directly reference allocations, but e.g. other GEPs
iterate_gep_indices(FID, STARTLOC, RESULT, IID, LEVEL) :-
memequals(FID,STARTLOC,_,_,FID,ALTSTART,_,_),
iterate_gep_indices(FID, ALTSTART, RESULT, IID, LEVEL).


//get the vreg of all return instructions of one function
.decl get_ret_register(functionid: _functionid, returnregister: symbol)
//.output get_ret_register(delimiter=",")
get_ret_register(FID, RREG) :- instruction(BID, IID, _, OPC), block(FID, BID, _), 
OPC = "ret", get_first_operand(IID, RREG), is_vreg(RREG).


.decl get_call_argument_and_function_register(instructionid: _instructionid, caller_functionid: _functionid, call_arg: symbol, 
called_functionid: _functionid, functionreg: symbol, argumenttype: symbol)
//.output get_call_argument_and_function_register(delimiter=",")
get_call_argument_and_function_register(IID, CFID, CARG, FID, VREG, ARGTYPE) :- 
instruction(BID, IID, _, _), block(CFID, BID, _), is_call_instruction(IID),
get_function_for_call_instruction(FNAME, IID),
function(FID, FNAME, "define", _), //only get self defined functions
get_ith_argument_register(FID, ARGNUM, _, VREG, ARGTYPE),
get_ith_call_argument(IID, ARGNUM, CARG), is_vreg(CARG).


.decl get_ith_argument_register(functionid: _functionid, i:number, argid:_argumentid, argument: _vreg, argumenttype: symbol)
//.output get_ith_argument_register(delimiter=",")
get_ith_argument_register(FID, I, ARGID, VREG, ARGTYPE) :- argument(FID, ARGID, VREG, ARGTYPE), I = 1, !argument(FID, ARGID-1, _, _). 
get_ith_argument_register(FID, I, ARGID, VREG, ARGTYPE) :- argument(FID, ARGID, VREG, ARGTYPE), I > 1,
I = I2+1, get_ith_argument_register(FID, I2, ARGID-1, _, _).

.decl get_ith_call_argument(instructionid: _instructionid, i:number, val: symbol)
//.output get_ith_call_argument(delimiter=",")
get_ith_call_argument(IID, I, VAL) :- 
is_call_instruction(IID), 
get_num_operands(IID, ARGNUM2), ARGNUM = ARGNUM2-1,
get_ith_operand(IID, I, VAL),
I<=ARGNUM.

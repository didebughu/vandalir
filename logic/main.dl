//includes
#include "points-to.dl"

//types

//inputs
.decl function(functionid: number, functionname: symbol, functiontype: symbol, returntype: symbol)
.input function(delimiter=";")
.decl argument(functionid: number, argumentid: number, argumenttype: symbol)
.input argument(delimiter=";")
.decl block(functionid: number, blockid: number, label: symbol, predecessors: symbol)
.input block(delimiter=";")
.decl instruction(blockid: number, instructionid: number, virtualregister: symbol, opcode: symbol)
.input instruction(delimiter=";")
.decl operand(instructionid: number, operandid: number, operandvalue: symbol)
.input operand(delimiter=";")

//rules & analysis 

/*
//next instruction test
.decl next_instruction(start: number, startop: symbol, end: number, endop: symbol)
next_instruction(I1, X, I2, Y) :- instruction(B1, I1, _, X), instruction(B2, I2, _, Y), B2=B1, I2=I1+1, block(F1, B1), block(F2, B2), F1=F2.
next_instruction(I1, X, I2, Y) :- instruction(B1, I1, _, X), instruction(B2, I2, _, Y), B2=B1, I2=I1+1.
*/

//get only call instruction
.decl is_call_instruction(instructionid: number, blockid: number)
is_call_instruction(IID, BID) :- instruction(BID, IID, _, OPC), OPC = "call".

//get only call strncpy instructions
.decl is_strncpy_call_instruction(instructionid: number, blockid: number)
is_strncpy_call_instruction(IID, BID) :- is_call_instruction(IID, BID), operand(IID, _, OV), OV = "strncpy".

//get only call strlen instructions
.decl is_strlen_call_instruction(instructionid: number, blockid: number)
is_strlen_call_instruction(IID, BID) :- is_call_instruction(IID, BID), operand(IID, _, OV), OV = "strlen".

//get only call fgets instructions
.decl is_fgets_call_instruction(instructionid: number, blockid: number)
is_fgets_call_instruction(IID, BID) :- is_call_instruction(IID, BID), operand(IID, _, OV), OV = "fgets".

//get only call strlen instructions
.decl is_malloc_call_instruction(instructionid: number, blockid: number)
is_malloc_call_instruction(IID, BID) :- is_call_instruction(IID, BID), operand(IID, _, OV), OV = "malloc".

//get size of alloca
.decl get_size_of_alloca(size: number, instructionid: number)
get_size_of_alloca(SIZE, IID) :- instruction(_, IID, _, OPC), OPC = "alloca",
operand(IID, OID1, OV1), operand(IID, OID2, _), operand(IID, OID3, _),
OID2 = OID1+1, OID3 = OID2+1,
SIZE = to_number(OV1).

//get size of buffer by virtual register
.decl get_size_by_vreg(size: number, blockid: number, virtualregister: symbol)
//case alloca (end recursion)
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "alloca",
get_size_of_alloca(VAL, IID).
//case call strlen
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "call",
operand(IID, OID1, OV1), operand(IID, OID2, _), 
OID2 = OID1+1, is_strlen_call_instruction(IID, BID),
get_size_by_vreg(VAL, BID, OV1).
//case getelementptr
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "getelementptr", 
operand(IID, OID1, OV1), operand(IID, OID2, _), operand(IID, OID3, _),
OID2 = OID1+1, OID3 = OID2+1, get_size_by_vreg(VAL, BID, OV1).
//case add
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "add",
operand(IID, OID1, OV1), operand(IID, OID2, OV2),
OID2 = OID1+1, VAL=TMP+to_number(OV2), get_size_by_vreg(TMP, BID, OV1).
//case sub
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "sub",
operand(IID, OID1, OV1), operand(IID, OID2, OV2),
OID2 = OID1+1, VAL=TMP-to_number(OV2), get_size_by_vreg(TMP, BID, OV1).
//case trunc
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "trunc",
operand(IID, _, OV1),
get_size_by_vreg(VAL, BID, OV1).
//case malloc
/*
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), contains("call", OPC),
operand(IID, OID1, OV1), operand(IID, OID2, _), 
OID2 = OID1+1, is_malloc_call_instruction(IID, BID),
VAL = to_number(OV1).
*/
//case load
//points-to analysis

//if call instruction give called function name
.decl get_function_for_call_instruction(function: symbol, instructionid: number, blockid: number)
//case not a call instruction
get_function_for_call_instruction(OPC, IID, BID) :- instruction(BID, IID, _, OPC), OPC != "call".
//a call instruction
get_function_for_call_instruction(NAME, IID, BID) :- instruction(BID, IID, _, OPC), OPC = "call",
MAXID = max OID : {operand(IID, OID, _) }, operand(IID, MAXID, NAME).


//strncpy vulnerable to bo
.decl is_vulnerable_strncpy_call_instruction(instructionid: number, blockid: number)
//computed n
is_vulnerable_strncpy_call_instruction(IID, BID) :- is_strncpy_call_instruction(IID, BID), 
operand(IID, OID1, OV1), operand(IID, OID2, _), operand(IID, OID3, N), operand(IID, OID4, _), 
OID2 = OID1+1, OID3 = OID2+1, OID4 = OID3+1, 
get_size_by_vreg(DEST_SIZE, BID, OV1), contains("%", N), 
get_size_by_vreg(COPY_SIZE, BID, N),
DEST_SIZE < COPY_SIZE.
//hardcoded n
is_vulnerable_strncpy_call_instruction(IID, BID) :- is_strncpy_call_instruction(IID, BID), 
operand(IID, OID1, OV1), operand(IID, OID2, _), operand(IID, OID3, N), operand(IID, OID4, _), 
OID2 = OID1+1, OID3 = OID2+1, OID4 = OID3+1, 
get_size_by_vreg(DEST_SIZE, BID, OV1), 
!contains("%", N),
DEST_SIZE < to_number(N).

//fgets vulnerable to bo
.decl is_vulnerable_fgets_call_instruction(instructionid: number, blockid: number)
//computed n
is_vulnerable_fgets_call_instruction(IID, BID) :- is_fgets_call_instruction(IID, BID), 
operand(IID, OID1, OV1), operand(IID, OID2, N), operand(IID, OID3, _), operand(IID, OID4, _), 
OID2 = OID1+1, OID3 = OID2+1, OID4 = OID3+1, 
get_size_by_vreg(DEST_SIZE, BID, OV1), contains("%", N), 
get_size_by_vreg(COPY_SIZE, BID, N),
DEST_SIZE < COPY_SIZE.
//hardcoded n
is_vulnerable_fgets_call_instruction(IID, BID) :- is_fgets_call_instruction(IID, BID), 
operand(IID, OID1, OV1), operand(IID, OID2, N), operand(IID, OID3, _), operand(IID, OID4, _), 
OID2 = OID1+1, OID3 = OID2+1, OID4 = OID3+1, 
get_size_by_vreg(DEST_SIZE, BID, OV1), 
!contains("%", N),
DEST_SIZE < to_number(N).

//output
.decl print_vulnerable(functionname: symbol, label: symbol, virtualregister: symbol, opcode: symbol)
.output print_vulnerable(delimiter=",")
print_vulnerable(NAME, LAB, VREG, OUT) :- instruction(BID, IID, VREG, _), 
get_function_for_call_instruction(OUT, IID, BID),
is_vulnerable_strncpy_call_instruction(IID, BID), block(FID, BID, LAB, _), function(FID, NAME, _, _).

print_vulnerable(NAME, LAB, VREG, OUT) :- instruction(BID, IID, VREG, _),
get_function_for_call_instruction(OUT, IID, BID), 
is_vulnerable_fgets_call_instruction(IID, BID), block(FID, BID, LAB, _), function(FID, NAME, _, _).
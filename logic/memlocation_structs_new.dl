//structAll Elements

//stack allocations of struct (all element), when a single struct is allocated
memlocation(FID, LOC, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", 
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"), 
get_second_operand(IID, SIZE),
is_numeric(SIZE), to_number(SIZE) = 1,
is_struct(BASETYPE),
CAT = cat("structAll~1~",BASETYPE).

//stack allocations of struct (all element) when an array of structs is allocated
memlocation(FID, LOCATION, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", 
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"), 
get_second_operand(IID, SIZE),
is_numeric(SIZE), to_number(SIZE) > 1,
is_struct(BASETYPE),
CAT = cat("structAll~1~",BASETYPE),
NUM >= 0, NUM < to_number(SIZE), anumber(NUM),
LOCATION = cat(cat(LOC, "."), to_string(NUM)).

//subelements of structs
//stack allocations of subelements of a struct, matching structAll
memlocation(FID, LOCATION, TYPE, CAT) :- 
memlocation(FID, LOCATIONSTRUCT, _, CATSTRUCT),
STRUCTALL = substr(CATSTRUCT, 0, 10),
STRUCTALL = "structAll~",
VALUES = substr(CATSTRUCT, 10, strlen(CATSTRUCT)),
STRUCT = @get_behind_seperator(VALUES),
TYPE = cat(BASETYPE,"*"),
memlocation_alloca_struct_subelements(FID, LOCATION, LOCATIONSTRUCT, STRUCT, BASETYPE, CAT)
.

//subelements of arrays

//case only 1-dim array, not a struct => spawn arrayIndex elements
memlocation(FID, LOCATION, TYPE, CAT) :- 
memlocation_catstr_subset(FID, LOCSTRUCT, CATSTRUCT),
ARRAYALL = substr(CATSTRUCT, 0, 9),
ARRAYALL = "arrayAll~",
VALUES = substr(CATSTRUCT, 9, strlen(CATSTRUCT)),
SIZESTR = substr(VALUES, 0, @get_before_seperator(VALUES)),
TYPE = cat(BASETYPE,"*"),
BASETYPE = @get_behind_seperator(VALUES),
!is_struct(BASETYPE),
LOCATION = cat(LOCSTRUCT, ".", ISTR),
ISTR = to_string(I),
is_numeric(SIZE),
I >= 0, I < to_number(SIZE),
get_all_getelementptr_indices(I),
ARRAYLEVEL = @get_num_xseperators(SIZESTR),
ARRAYLEVEL = 0,
get_xth_entry_in_separated_str(SIZE, 1, _, SIZESTR),
CAT = "arrayIndex".

//case only 1-dim array, which contains a struct => span structAll element
memlocation(FID, LOCATION, TYPE, CAT) :- 
memlocation_catstr_subset(FID, LOCSTRUCT, CATSTRUCT),
ARRAYALL = substr(CATSTRUCT, 0, 9),
ARRAYALL = "arrayAll~",
VALUES = substr(CATSTRUCT, 9, strlen(CATSTRUCT)),
SIZESTR = substr(VALUES, 0, @get_before_seperator(VALUES)),
TYPE = cat(BASETYPE,"*"),
BASETYPE = @get_behind_seperator(VALUES),
is_struct(BASETYPE),
LOCATION = cat(LOCSTRUCT, ".", ISTR),
ISTR = to_string(I),
is_numeric(SIZE),
I >= 0, I < to_number(SIZE),
get_all_getelementptr_indices(I),
ARRAYLEVEL = @get_num_xseperators(SIZESTR),
ARRAYLEVEL = 0,
get_xth_entry_in_separated_str(SIZE, 1, _, SIZESTR),
CAT = cat("structAll~1~",BASETYPE).

//case multi-dim array => spawn additional arrayAll Elements
memlocation(FID, LOCATION, TYPE, CAT) :- 
memlocation_catstr_subset(FID, LOCSTRUCT, CATSTRUCT),
ARRAYALL = substr(CATSTRUCT, 0, 9),
ARRAYALL = "arrayAll~",
VALUES = substr(CATSTRUCT, 9, strlen(CATSTRUCT)),
SIZESTR = substr(VALUES, 0, @get_before_seperator(VALUES)),
TYPE = cat(BASETYPE,"*"),
BASETYPE = @get_behind_seperator(VALUES),
LOCATION = cat(LOCSTRUCT, ".", ISTR),
ISTR = to_string(I),
is_numeric(SIZE),
I >= 0, I < to_number(SIZE),
get_all_getelementptr_indices(I),
ARRAYLEVEL = @get_num_xseperators(SIZESTR),
ARRAYLEVEL > 0,
get_xth_entry_in_separated_str(SIZE, 1, _, SIZESTR),
RESIDUAL = @get_behind_xseperator(SIZESTR),
CAT = cat("arrayAll~",RESIDUAL,"~",BASETYPE).




//helper to generate subelements of struct
.decl memlocation_alloca_struct_subelements(functionid: _functionid, outputmemlocation: symbol, startmemlocation: symbol, structname: symbol, memtype: symbol, memcategory: _memcategory)
//input: FID, STARTLOC, STRUCTNAME, TYPE
//output: OUTPUT(=final location), CAT
//.output memlocation_alloca_struct_subelements(delimiter=",")

//case: normal struct element, which is neither an array not another struct
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, TYPE, OPSIZE),
!is_struct(TYPE),
!is_multidimensional(OPSIZE),
to_number(OPSIZE) = 1,
get_all_getelementptr_indices(OPID), //limit evaluated indices to those used by getelemeptr
OUTPUT = cat(cat(STARTLOC, "."), to_string(OPID)),
CAT = "structIndex",
concatenated(FID, STARTLOC).

//case struct subelement is a simple struct
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, TYPE, OPSIZE),
is_struct(TYPE),
!is_multidimensional(OPSIZE),
to_number(OPSIZE) = 1,
get_all_getelementptr_indices(OPID), //limit evaluated indices to those used by getelemeptr
OUTPUT = cat(cat(STARTLOC, "."), to_string(OPID)),
CAT = cat("structAll~1~",TYPE),
concatenated(FID, STARTLOC).

//case is array => create arrayAll
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
to_number(OPSIZE) > 1,
get_all_getelementptr_indices(OPID), //limit evaluated indices to thouse used by getelemeptr
OUTPUT = cat(cat(STARTLOC, "."), to_string(OPID)),
TYPE = OPTYPE,
CAT = cat("arrayAll~",OPSIZE,"~",OPTYPE),
concatenated(FID, STARTLOC).
/*
//recursive helper function to enumerate arrays
.decl memlocation_alloca_array_enumerator(valuestr: symbol, memlocation: symbol, enumerator: number, memtyp: symbol, memcategory: _memcategory)
//input: SIZESTR, NUM
//output: LOC, CAT, TYPE

//base
memlocation_alloca_array_enumerator(VALUES, LOC, NUM, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_struct(TYPE),
!is_alloca_multidimensional(IID),

OPC = "alloca", CAT = "arrayIndexXXX",  
//get type and size from sizestr
get_second_operand(IID, SIZE), is_numeric(SIZE), to_number(SIZE) > 1,
get_first_operand(IID, TYPE), 

NUM = 0, NUM<to_number(SIZE).
//recursion
memlocation_alloca_array_enumerator(SIZESTR, LOC, NUM, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_struct(TYPE),
!is_alloca_multidimensional(IID),
OPC = "alloca", CAT = "arrayIndex",  
get_second_operand(IID, SIZE), is_numeric(SIZE), to_number(SIZE) > 1,
get_first_operand(IID, TYPE), NUM > 0, NUM<to_number(SIZE), NUM = NUM2+1,
memlocation_alloca_array_enumerator(FID, LOC, NUM2, TYPE, CAT).
*/

/*
//TODO: fix this broken relation, by understanding the similar implementation in memlocation.dl
//helper to generate subelements of arrays
.decl memlocation_new_multidim_array_enumerator(sizestr: symbol, level: number, location: symbol, startlocation: symbol)
.output memlocation_new_multidim_array_enumerator(delimiter=";")
//input: IID, LEVEL(not always)
//output: LOC
//intern: STARTLOC (only for recursion)

//case level=0
memlocation_new_multidim_array_enumerator(SIZESTR, LEVEL, LOC, STARTLOC) :-
LEVEL = 0, 
memlocation(_, STARTLOC, _, _), //ground STARTLOCK
get_all_getelementptr_indices(I), //limit evaluated indices to thouse used by getelemeptr
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_xth_entry_in_separated_str(ELEMENTS_IN_LEVEL, LEVEL+1, _, SIZESTR),
is_numeric(ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I).

//recursive case
memlocation_new_multidim_array_enumerator(SIZESTR, LEVEL, LOC, STARTLOC) :-
NUMOPERANDS = @get_num_seperators(SIZESTR),
LEVEL < NUMOPERANDS,
anumber(LEVEL), 
get_all_getelementptr_indices(I), //limit evaluated indices to those used by getelemeptr
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_xth_entry_in_separated_str(ELEMENTS_IN_LEVEL, LEVEL+1, _, SIZESTR),
is_numeric(ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I),
memlocation_new_multidim_array_enumerator(SIZESTR, LEVEL-1, STARTLOC, _).
*/

//helper for helper
.decl get_xth_entry_in_separated_str(res: symbol, i: number, string: symbol, origstring: symbol)
//base
get_xth_entry_in_separated_str(RES, I, STR, OSTR) :-
is_numeric(RES),
I = 1,
contains("x", STR),
RES = substr(STR, 0, @get_before_xseperator(STR)),
//RES = STR,
STR = OSTR,
opval(STR).
//recursion


get_xth_entry_in_separated_str(RES, I, STR, OSTR) :-
is_numeric(RES),
I > 1, anumber(I),
contains("x", STROLD),
STR = @get_behind_xseperator(STROLD),
RES = substr(STR, 0, @get_before_xseperator(STR)),
get_xth_entry_in_separated_str(_, I-1, STROLD, OSTR)
.

get_xth_entry_in_separated_str(RES, I, STR, OSTR) :-
is_numeric(RES),
I = 1,
!contains("x", STR),
RES = STR,
STR = OSTR,
opval(STR).


.decl memlocation_catstr_subset(functionid: _functionid, structvreg: symbol, category: symbol)
memlocation_catstr_subset(FID, LOCSTRUCT, CATSTRUCT) :-
memlocation(FID, LOCSTRUCT, _, CATSTRUCT),
strlen(CATSTRUCT) > 9.
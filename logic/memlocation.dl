//memtype e.g. i8*
.decl memtype(memtype: symbol)
memtype(MEM) :- MEM = "unknown". //unkown type
memtype(MEM) :- type(MEM).

//memcategory
.decl memcategory(memcategory: _memcategory)
memcategory(MEM) :- MEM = "stack".
memcategory(MEM) :- MEM = "heap".
memcategory(MEM) :- MEM = "global".
memcategory(MEM) :- MEM = "arrayAll".
memcategory(MEM) :- MEM = "arrayIndex".
memcategory(MEM) :- MEM = "structAll".
memcategory(MEM) :- MEM = "structIndex".
memcategory(MEM) :- MEM = "vreg".

.decl memlocation(functionid: _functionid, memlocation: symbol, memtyp: symbol, memcategory: _memcategory)
.output memlocation(delimiter=",")
//stack allocations

//stack allocations of one element.
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, LOC, OPC), block(FID, BID, _),
OPC = "alloca", CAT = "stack", memcategory(CAT), 
get_first_operand(IID, TYPE), is_numeric(SIZE), to_number(SIZE) = 1,
!is_struct(TYPE),
get_second_operand(IID, SIZE).

//1-dim arrays
//stack allocations of array (all element).
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, LOC, OPC), block(FID, BID, _),
OPC = "alloca", CAT = "arrayAll", memcategory(CAT), !is_alloca_multidimensional(IID),
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"), 
is_numeric(SIZE), to_number(SIZE) > 1,
get_second_operand(IID, SIZE).
//stack allocations of array (index elements).
memlocation(FID, LOCATION, TYPE, CAT) :- 
memlocation_alloca_array_enumerator(FID, LOC, NUM, BASETYPE, CAT),
TYPE = cat(BASETYPE,"*"),
!is_struct(BASETYPE),
LOCATION = cat(cat(LOC, "."), to_string(NUM)).


//multi-dim arrays
//stack allocations of array (all element).

memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, _, OPC), block(FID, BID, _),
OPC = "alloca", CAT = "arrayAll", memcategory(CAT), is_alloca_multidimensional(IID),
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"),  
memlocation_multidim_array_enumerator(IID, _, _, LOC).
//stack allocations of array (index elements), which are no structs
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, _, OPC), block(FID, BID, _),
!is_struct(TYPE),
OPC = "alloca", CAT = "arrayIndex", memcategory(CAT), is_alloca_multidimensional(IID),
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"), 
get_num_operands(IID, NUMOPERANDS),
LEVEL = NUMOPERANDS-2,
memlocation_multidim_array_enumerator(IID, LEVEL, LOC, _).
//stack allocations of array (index elements), which are structs (struct All elements)
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, _, OPC), block(FID, BID, _),
OPC = "alloca", CAT = "structAll", memcategory(CAT), is_alloca_multidimensional(IID),
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"), 
is_struct(BASETYPE),
get_num_operands(IID, NUMOPERANDS),
LEVEL = NUMOPERANDS-2,
memlocation_multidim_array_enumerator(IID, LEVEL, LOC, _).
//stack allocations of array (index elements), which are structs (struct subelements)
memlocation(FID, LOCATION, TYPE, CAT) :- instruction(BID, IID, _, OPC), block(FID, BID, _),
OPC = "alloca", memcategory(CAT), is_alloca_multidimensional(IID),
get_first_operand(IID, ALLOCTYPE),
is_struct(ALLOCTYPE),
get_num_operands(IID, NUMOPERANDS),
LEVEL = NUMOPERANDS-2,
memlocation_multidim_array_enumerator(IID, LEVEL, STARTLOC, _),
TYPE = cat(BASETYPE,"*"), 
memlocation_alloca_struct_subelements(FID, LOCATION, STARTLOC, ALLOCTYPE, BASETYPE, CAT).

//structs (not contained within multidim arrays)
//stack allocations of struct (all element), when a single struct is allocated
memlocation(FID, LOC, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", 
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"), 
get_second_operand(IID, SIZE),
is_numeric(SIZE), to_number(SIZE) = 1,
is_struct(BASETYPE),
CAT = "structAll".
//stack allocations of struct (all element) when an array of structs is allocated
memlocation(FID, LOCATION, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", 
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"), 
get_second_operand(IID, SIZE),
is_numeric(SIZE), to_number(SIZE) > 1,
is_struct(BASETYPE),
CAT = "structAll",
NUM >= 0, NUM < to_number(SIZE), anumber(NUM),
LOCATION = cat(cat(LOC, "."), to_string(NUM)).

//parse subelements of struct
//stack allocations of subelements of a struct (index elements) when a single struct is allocated
memlocation(FID, LOCATION, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", get_first_operand(IID, ALLOCTYPE), get_second_operand(IID, ALLOCSIZE),
is_numeric(ALLOCSIZE), to_number(ALLOCSIZE) = 1,
struct(_, STRUCTNAME, _),
STRUCTNAME = ALLOCTYPE,
TYPE = cat(BASETYPE,"*"), 
memlocation_alloca_struct_subelements(FID, LOCATION, LOC, STRUCTNAME, BASETYPE, CAT).
//stack allocations of subelements of a struct (index elements) when a 1-dim array of structs is allocated
memlocation(FID, LOCATION, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", get_first_operand(IID, STRUCTNAME), get_second_operand(IID, SIZE),
is_numeric(SIZE), to_number(SIZE) > 1,
is_struct(STRUCTNAME),
NUM >= 0, NUM < to_number(SIZE), anumber(NUM),
STARTLOCATION = cat(cat(LOC, "."), to_string(NUM)),
TYPE = cat(BASETYPE,"*"),
memlocation_alloca_struct_subelements(FID, LOCATION, STARTLOCATION, STRUCTNAME, BASETYPE, CAT).


//heap allocations
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, LOC, _), block(FID, BID, _),
is_heap_allocation_call(IID), CAT = "heap", memcategory(CAT),
TYPE = "i8*".
//global allocations of one element
memlocation(FID, LOC, TYPE, CAT) :- 
global(LOC, TYPE, SIZE),
SIZE = 1,
FID = -1, CAT = "global", memcategory(CAT).
//global allocations of array (all element).
memlocation(FID, LOC, TYPE, CAT) :- 
global(LOC, BASETYPE, SIZE), TYPE = cat(BASETYPE, "*"),
SIZE > 1,
FID = -1, CAT = "arrayAll", memcategory(CAT).
//global allocations of array (index elements).
memlocation(FID, LOCATION, TYPE, CAT) :- 
global(LOC, BASETYPE, SIZE), 
TYPE = cat(BASETYPE, "*"),
SIZE > 1,
memlocation_global_array_enumerator(FID, LOC, NUM, BASETYPE, CAT),
//NUM = SIZE-1,
LOCATION = cat(cat(LOC, "."), to_string(NUM)).


//vreg function call
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC = "call", get_function_for_call_instruction(FNAME, IID), function(_, FNAME, _, RETTYPE),
LOC = VREG,
CAT = "vreg",
TYPE = RETTYPE.
//vreg no load
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC != "load", OPC != "alloca", OPC != "getelementptr", !is_heap_allocation_call(IID),
VREG != "%-1",
LOC = VREG,
CAT = "vreg", memcategory(CAT),
TYPE = "unknown". 
//vreg load
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC = "load",
VREG != "%-1",
LOC = VREG,
CAT = "vreg", memcategory(CAT),
get_first_operand(IID, TYPE).
//vreg getelementptr
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, _, VREG, OPC), block(FID, BID, _),
OPC = "getelementptr",
LOC = VREG,
CAT = "vreg", memcategory(CAT),
TYPE = "unknown".
//function arguments
memlocation(FID, LOC, TYPE, CAT) :- argument(FID, _, LOC, TYPE), CAT = "stack".



//recursive helper function to enumerate alloca arrays
.decl memlocation_alloca_array_enumerator(functionid: _functionid, memlocation: symbol, enumerator: number, memtyp: symbol, memcategory: _memcategory)
memlocation_alloca_array_enumerator(FID, LOC, NUM, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", CAT = "arrayIndex", memcategory(CAT), 
get_second_operand(IID, SIZE), is_numeric(SIZE), to_number(SIZE) > 1,
get_first_operand(IID, TYPE), NUM = 0, NUM<to_number(SIZE).

memlocation_alloca_array_enumerator(FID, LOC, NUM, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", CAT = "arrayIndex", memcategory(CAT), 
get_second_operand(IID, SIZE), is_numeric(SIZE), to_number(SIZE) > 1,
get_first_operand(IID, TYPE), NUM > 0, NUM<to_number(SIZE), NUM = NUM2+1,
memlocation_alloca_array_enumerator(FID, LOC, NUM2, TYPE, CAT).


//recursive helper function to enumerate global arrays
//TODO: this one seems quite ugly, might benefit from a rewrite
.decl memlocation_global_array_enumerator(functionid: _functionid, memlocation: symbol, enumerator: number, memtyp: symbol, memcategory: _memcategory)
//.output memlocation_global_array_enumerator(delimiter=",")
memlocation_global_array_enumerator(FID, LOC, NUM, TYPE, CAT) :-
global(LOC, TYPE, SIZE),
NUM = 0, NUM<SIZE,
SIZE > 1,
FID = -1, CAT = "arrayIndex", memcategory(CAT).
memlocation_global_array_enumerator(FID, LOC, NUM, TYPE, CAT) :-
global(LOC, TYPE, SIZE),
NUM > 0, NUM<SIZE, NUM = NUM2+1,
SIZE > 1,
memlocation_global_array_enumerator(FID, LOC, NUM2, TYPE, CAT),
FID = -1, CAT = "arrayIndex", memcategory(CAT).

//recursive helper to enumerate multidimensional arrays
.decl memlocation_multidim_array_enumerator(instructionid: _instructionid, level: number, location: symbol, startlocation: symbol)
//.output memlocation_multidim_array_enumerator(delimiter=";")
//case level=0
memlocation_multidim_array_enumerator(IID, LEVEL, LOC, STARTLOC) :-
instruction(_, IID, STARTLOC, OPC), OPC = "alloca",
get_alloca_arraylevel(IID, ARRAYLEVEL), ARRAYLEVEL > 1,
LEVEL = 0, 
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_ith_operand(IID, LEVEL+2, ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I).
//recursive case
memlocation_multidim_array_enumerator(IID, LEVEL, LOC, STARTLOC) :-
instruction(_, IID, _, OPC), OPC = "alloca",
get_alloca_arraylevel(IID, ARRAYLEVEL), ARRAYLEVEL > 1, 
get_num_operands(IID, NUMOPERANDS),
LEVEL < NUMOPERANDS-1,
anumber(LEVEL), 
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_ith_operand(IID, LEVEL+2, ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I),
memlocation_multidim_array_enumerator(IID, LEVEL-1, STARTLOC, _).


//recursive helper to enumerate struct allocations (all element)
.decl memlocation_alloca_struct_enumerator(functionid: _functionid, memlocation: symbol, enumerator: number, memtyp: symbol, memcategory: _memcategory)
memlocation_alloca_struct_enumerator(FID, LOC, NUM, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
OPC = "alloca", memcategory(CAT), 
get_second_operand(IID, SIZE), is_numeric(SIZE), to_number(SIZE) > 1,
NUM = 0, NUM<to_number(SIZE),
get_first_operand(IID, TYPE).

memlocation_alloca_struct_enumerator(FID, LOC, NUM, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
OPC = "alloca", memcategory(CAT), 
get_first_operand(IID, TYPE),
get_second_operand(IID, SIZE), is_numeric(SIZE), to_number(SIZE) > 1,
NUM > 0, NUM<to_number(SIZE), NUM<to_number(SIZE), NUM = NUM2+1,
memlocation_alloca_struct_enumerator(FID, LOC, NUM2, TYPE, CAT).

//recursive helpter to enumerate struct sub elements (index elements)
.decl memlocation_alloca_struct_subelements(functionid: _functionid, outputmemlocation: symbol, startmemlocation: symbol, structname: symbol, memtype: symbol, memcategory: _memcategory)
.output memlocation_alloca_struct_subelements(delimiter=",")

//normal struct element, which is not an array
//case: normal struct element, which is neither an array not another struct
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
!is_struct(OPTYPE),
!is_multidimensional(OPSIZE),
to_number(OPSIZE) = 1,
OUTPUT = cat(cat(STARTLOC, "."), to_string(OPID)),
TYPE = OPTYPE,
CAT = "structIndex",
concatenated(FID, STARTLOC).
//case: subelement is a struct -> AllElement
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
is_struct(OPTYPE),
!is_multidimensional(OPSIZE),
is_numeric(OPSIZE),
to_number(OPSIZE) = 1,
OUTPUT = cat(cat(STARTLOC, "."), to_string(OPID)),
TYPE = OPTYPE,
CAT = "structAll",
concatenated(FID, STARTLOC).
//case: subelement is a struct -> Parse actual struct recursively
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
is_struct(OPTYPE),
!is_multidimensional(OPSIZE),
is_numeric(OPSIZE),
to_number(OPSIZE) = 1,
STARTLOCINNERSTRUCT = cat(cat(STARTLOC, "."), to_string(OPID)),
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOCINNERSTRUCT, OPTYPE, TYPE, CAT),
concatenated(FID, STARTLOC).

//struct elements which are 1-dim arrays
//case All Element for 1-dim arrays as sub element
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
!is_multidimensional(OPSIZE),
to_number(OPSIZE) > 1,
OUTPUT = cat(cat(STARTLOC, "."), to_string(OPID)),
TYPE = OPTYPE,
CAT = "arrayAll",
concatenated(FID, STARTLOC).
//case Index Element for 1-dim arrays as sub element, the 1-dim array is not a struct element
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
!is_struct(OPTYPE),
!is_multidimensional(OPSIZE),
to_number(OPSIZE) > 1,
OUTPUT = cat(cat(cat(cat(STARTLOC, "."), to_string(OPID)), "."), to_string(NUM)),
NUM >= 0, NUM < to_number(OPSIZE), anumber(NUM),
TYPE = OPTYPE,
CAT = "arrayIndex",
concatenated(FID, STARTLOC).
//case Index Element for 1-dim arrays as sub element, the 1-dim array is not a struct element
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
is_struct(OPTYPE),
!is_multidimensional(OPSIZE),
to_number(OPSIZE) > 1,
OUTPUT = cat(cat(cat(cat(STARTLOC, "."), to_string(OPID)), "."), to_string(NUM)),
NUM >= 0, NUM < to_number(OPSIZE), anumber(NUM),
TYPE = OPTYPE,
CAT = "structAll",
concatenated(FID, STARTLOC).
//case Index Element for 1-dim arrays as sub element, the 1-dim array is a struct element
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
is_struct(OPTYPE),
!is_multidimensional(OPSIZE),
to_number(OPSIZE) > 1,
STARTLOCINNERSTRUCT = cat(cat(cat(cat(STARTLOC, "."), to_string(OPID)), "."), to_string(NUM)),
NUM >= 0, NUM < to_number(OPSIZE), anumber(NUM),
memlocation_alloca_struct_subelements(FID, OUTPUT, STARTLOCINNERSTRUCT, OPTYPE, TYPE, CAT),
concatenated(FID, STARTLOC).




//case MultiDim Array
/*
memlocation_alloca_struct_subelements(OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
!is_struct(OPTYPE),
is_multidimensional(OPSIZE),




.decl memlocation_struct_subelement_multidim_array_enumerator(, level: number, location: symbol, startlocation: symbol)
memlocation_struct_subelement_multidim_array_enumerator(LEVEL, LOC, STARTLOC) :-
LEVEL = 0, 
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_ith_operand(IID, LEVEL+2, ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I).
//recursive case
memlocation_struct_subelement_multidim_array_enumerator(IID, LEVEL, LOC, STARTLOC) :-
get_num_operands(IID, NUMOPERANDS),
LEVEL < NUMOPERANDS-1,
anumber(LEVEL), 
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_ith_operand(IID, LEVEL+2, ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I),
memlocation_struct_subelement_multidim_array_enumerator(IID, LEVEL-1, STARTLOC, _).
*/


//not sure what this is or whether this is used
.decl get_val_of_load(instructionid: _instructionid, value: symbol)
get_val_of_load(IID, VAL) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _), OPC = "load",
get_first_operand(IID, LOADTYPE), !is_pointer(LOADTYPE),
points_to(FID, VREG, _, _, FID, VAL, _, _).
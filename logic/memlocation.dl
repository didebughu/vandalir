//memtype e.g. i8*
.decl memtype(memtype: symbol)
memtype(MEM) :- MEM = "unknown". //unkown type
memtype(MEM) :- type(MEM).


.decl memlocation(functionid: _functionid, memlocation: symbol, memtyp: symbol, memcategory: _memcategory)
.output memlocation(delimiter=",")
//stack allocations

//stack allocations of one element.
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, LOC, OPC), block(FID, BID, _),
OPC = "alloca", CAT = "stack",  
get_first_operand(IID, TYPE), is_numeric(SIZE), to_number(SIZE) = 1,
!is_struct(TYPE),
get_second_operand(IID, SIZE).

//1-dim arrays
//stack allocations of array (all element).
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, LOC, OPC), block(FID, BID, _),
OPC = "alloca", CAT = "arrayAll",  !is_alloca_multidimensional(IID),
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"), 
is_numeric(SIZE), to_number(SIZE) > 1,
get_second_operand(IID, SIZE).
//stack allocations of array (index elements).
memlocation(FID, LOCATION, TYPE, CAT) :- 
memlocation_alloca_array_enumerator(FID, LOC, NUM, BASETYPE, CAT),
TYPE = cat(BASETYPE,"*"),
!is_struct(BASETYPE),
get_all_getelementptr_indices(NUM), //limit evaluated indices to thouse used by getelemeptr
LOCATION = cat(cat(LOC, "."), to_string(NUM)).


//multi-dim arrays
//stack allocations of array (all element).

memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, _, OPC), block(FID, BID, _),
OPC = "alloca", CAT = "arrayAll",  is_alloca_multidimensional(IID),
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"),  
memlocation_multidim_array_enumerator(IID, _, _, LOC).
//stack allocations of array (index elements), which are no structs
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, _, OPC), block(FID, BID, _),
!is_struct(TYPE),
OPC = "alloca", CAT = "arrayIndex",  is_alloca_multidimensional(IID),
get_first_operand(IID, BASETYPE), TYPE = cat(BASETYPE,"*"), 
get_num_operands(IID, NUMOPERANDS),
LEVEL = NUMOPERANDS-2,
memlocation_multidim_array_enumerator(IID, LEVEL, LOC, _).


//heap allocations
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, LOC, _), block(FID, BID, _),
is_heap_allocation_call(IID), CAT = "heap", 
TYPE = "i8*".
//global allocations of one element
memlocation(FID, LOC, TYPE, CAT) :- 
global(LOC, _, TYPE, SIZE, _),
SIZE = 1,
FID = -1, CAT = "global".
//global allocations of array (all element).
memlocation(FID, LOC, TYPE, CAT) :- 
global(LOC, _, BASETYPE, SIZE, _), TYPE = cat(BASETYPE, "*"),
SIZE > 1,
FID = -1, CAT = "arrayAll".
//global allocations of array (index elements).
memlocation(FID, LOCATION, TYPE, CAT) :- 
global(LOC, _, BASETYPE, SIZE, _), 
TYPE = cat(BASETYPE, "*"),
SIZE > 1,
memlocation_global_array_enumerator(FID, LOC, NUM, BASETYPE, CAT),
//NUM = SIZE-1,
get_all_getelementptr_indices(NUM), //limit evaluated indices to thouse used by getelemeptr
LOCATION = cat(cat(LOC, "."), to_string(NUM)).

//vreg function call
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC = "call", get_function_for_call_instruction(FNAME, IID), function(_, FNAME, _, RETTYPE),
LOC = VREG,
CAT = "vreg",
TYPE = RETTYPE.

//vreg no load
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC != "load", OPC != "alloca", OPC != "getelementptr", !is_heap_allocation_call(IID),
VREG != "%-1",
LOC = VREG,
CAT = "vreg", 
TYPE = "unknown". 

//vreg load
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC = "load",
VREG != "%-1",
LOC = VREG,
CAT = "vreg", 
get_first_operand(IID, TYPE).

//vreg getelementptr
memlocation(FID, LOC, TYPE, CAT) :- instruction(BID, _, VREG, OPC), block(FID, BID, _),
OPC = "getelementptr",
LOC = VREG,
CAT = "vreg", 
TYPE = "unknown".

//function arguments
//function arguments (not containing equal userinput)
//TODO: might be a good idea to exclude userinput ==> no duplicates?
memlocation(FID, LOC, TYPE, CAT) :- 
argument(FID, _, LOC, TYPE), 
CAT = "stack"
//get_relative_argid(FID, ARGID, ARGID_REL),
//function(FID, FNAME, _, _)
.

//helper relations

//helper function that enumerates all getelementptr indices
.decl get_all_getelementptr_indices(index: number)
get_all_getelementptr_indices(INDEX) :-
instruction(BID, IID, _, OPC), block(_, BID, _),
OPC = "getelementptr",
get_ith_operand(IID, I, VAL), I>1,
is_numeric(VAL),
INDEX = to_number(VAL).

get_all_getelementptr_indices(INDEX) :-
instruction(BID, IID, _, OPC), block(FID, BID, _),
OPC = "getelementptr",
get_ith_operand(IID, I, VAL), I>1,
!is_numeric(VAL),
is_vreg(VAL),
get_int_by_vreg(INDEX, FID, VAL)
.

.decl get_all_getelementptr_indices_str(index: symbol)
get_all_getelementptr_indices_str(SYM) :- 
is_numeric(SYM), 
RES = to_number(SYM), 
get_all_getelementptr_indices(RES).


//recursive helper function to enumerate alloca arrays
.decl memlocation_alloca_array_enumerator(functionid: _functionid, memlocation: symbol, enumerator: number, memtyp: symbol, memcategory: _memcategory)
memlocation_alloca_array_enumerator(FID, LOC, NUM, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", CAT = "arrayIndex",  
get_second_operand(IID, SIZE), is_numeric(SIZE), to_number(SIZE) > 1,
get_first_operand(IID, TYPE), NUM = 0, NUM<to_number(SIZE).

memlocation_alloca_array_enumerator(FID, LOC, NUM, TYPE, CAT) :- 
instruction(BID, IID, LOC, OPC), block(FID, BID, _),
!is_alloca_multidimensional(IID),
OPC = "alloca", CAT = "arrayIndex",  
get_second_operand(IID, SIZE), is_numeric(SIZE), to_number(SIZE) > 1,
get_first_operand(IID, TYPE), NUM > 0, NUM<to_number(SIZE), NUM = NUM2+1,
memlocation_alloca_array_enumerator(FID, LOC, NUM2, TYPE, CAT).


//recursive helper function to enumerate global arrays
//TODO: this one seems quite ugly, might benefit from a rewrite
.decl memlocation_global_array_enumerator(functionid: _functionid, memlocation: symbol, enumerator: number, memtyp: symbol, memcategory: _memcategory)
//.output memlocation_global_array_enumerator(delimiter=",")
memlocation_global_array_enumerator(FID, LOC, NUM, TYPE, CAT) :-
global(LOC, _, TYPE, SIZE, _),
NUM = 0, NUM<SIZE,
SIZE > 1,
FID = -1, CAT = "arrayIndex".
memlocation_global_array_enumerator(FID, LOC, NUM, TYPE, CAT) :-
global(LOC, _, TYPE, SIZE, _),
NUM > 0, NUM<SIZE, NUM = NUM2+1,
SIZE > 1,
memlocation_global_array_enumerator(FID, LOC, NUM2, TYPE, CAT),
FID = -1, CAT = "arrayIndex".

//recursive helper to enumerate multidimensional arrays
.decl memlocation_multidim_array_enumerator(instructionid: _instructionid, level: number, location: symbol, startlocation: symbol)
//.output memlocation_multidim_array_enumerator(delimiter=";")
//case level=0
memlocation_multidim_array_enumerator(IID, LEVEL, LOC, STARTLOC) :-
instruction(_, IID, STARTLOC, OPC), OPC = "alloca",
get_alloca_arraylevel(IID, ARRAYLEVEL), ARRAYLEVEL > 1,
LEVEL = 0, 
get_all_getelementptr_indices(I), //limit evaluated indices to thouse used by getelemeptr
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_ith_operand(IID, LEVEL+2, ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I).
//recursive case
memlocation_multidim_array_enumerator(IID, LEVEL, LOC, STARTLOC) :-
instruction(_, IID, _, OPC), OPC = "alloca",
get_alloca_arraylevel(IID, ARRAYLEVEL), ARRAYLEVEL > 1, 
get_num_operands(IID, NUMOPERANDS),
LEVEL < NUMOPERANDS-1,
anumber(LEVEL), 
get_all_getelementptr_indices(I), //limit evaluated indices to thouse used by getelemeptr
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_ith_operand(IID, LEVEL+2, ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I),
memlocation_multidim_array_enumerator(IID, LEVEL-1, STARTLOC, _).





//case MultiDim Array
/*
memlocation_alloca_struct_subelements(OUTPUT, STARTLOC, STRUCTNAME, TYPE, CAT) :-
struct(SID, STRUCTNAME, _),
structoperand(SID, OPID, OPTYPE, OPSIZE),
!is_struct(OPTYPE),
is_multidimensional(OPSIZE),




.decl memlocation_struct_subelement_multidim_array_enumerator(, level: number, location: symbol, startlocation: symbol)
memlocation_struct_subelement_multidim_array_enumerator(LEVEL, LOC, STARTLOC) :-
LEVEL = 0, 
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_ith_operand(IID, LEVEL+2, ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I).
//recursive case
memlocation_struct_subelement_multidim_array_enumerator(IID, LEVEL, LOC, STARTLOC) :-
get_num_operands(IID, NUMOPERANDS),
LEVEL < NUMOPERANDS-1,
anumber(LEVEL), 
LOC = cat(cat(STARTLOC, "."), to_string(I)),
get_ith_operand(IID, LEVEL+2, ELEMENTS_IN_LEVEL),
I>=0, I<to_number(ELEMENTS_IN_LEVEL), anumber(I),
memlocation_struct_subelement_multidim_array_enumerator(IID, LEVEL-1, STARTLOC, _).
*/

.type _memcategory <: symbol


.decl memtype(memtype: symbol)
memtype(MEM) :- MEM = "unknown". //unkown type
memtype(MEM) :- type(MEM).


.decl memcategory(memcategory: _memcategory)
memcategory(MEM) :- MEM = "stack".
memcategory(MEM) :- MEM = "heap".
memcategory(MEM) :- MEM = "global".
memcategory(MEM) :- MEM = "vreg".


.decl memlocation(functionid: _functionid, memlocation: symbol, memtyp: symbol, memcategory: _memcategory)
//.output memlocation(delimiter=",")
//stack allocations
memlocation(FID, LOC, TYP, CAT) :- instruction(BID, IID, LOC, OPC), block(FID, BID, _),
OPC = "alloca", CAT = "stack", memcategory(CAT), 
get_second_operand(IID, TYP).
//heap allocations
memlocation(FID, LOC, TYP, CAT) :- instruction(BID, IID, LOC, _), block(FID, BID, _),
is_heap_allocation_call(IID), CAT = "heap", memcategory(CAT),
TYP = "i8*".
//globals
memlocation(FID, LOC, TYP, CAT) :- global(LOC),
FID = -1, CAT = "global", memcategory(CAT),
TYP = "unknown". //TODO: add parsing for globals
//vreg no load
memlocation(FID, LOC, TYP, CAT) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC != "load", OPC != "alloca", !is_heap_allocation_call(IID),
VREG != "%-1",
LOC = VREG,
CAT = "vreg", memcategory(CAT),
TYP = "unknown".  //TODO: add type info for call instructions via function return value
//vreg load
memlocation(FID, LOC, TYP, CAT) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC = "load",
VREG != "%-1",
LOC = VREG,
CAT = "vreg", memcategory(CAT),
get_first_operand(IID, TYP).


//find equal memory location (alias analysis)
.decl memequals(functionid1: _functionid, memlocation1: symbol, memtyp1: symbol, memcategory1: _memcategory, 
functionid2: _functionid, memlocation2: symbol, memtyp2: symbol, memcategory2: _memcategory)
//.output memequals(delimiter=",")

//case: (a <==> b) ==> (b <==> a)
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :- 
memlocation(FID1, LOC1, TYPE1, CAT1), 
memlocation(FID2, LOC2, TYPE2, CAT2), 
memequals(FID2, LOC2, TYPE2, CAT2, FID1, LOC1, TYPE1, CAT1).

//case points-to: (x -> a && x -> b) ==> (a <==> b)
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :- 
memlocation(FID1, LOC1, TYPE1, CAT1), 
memlocation(FID2, LOC2, TYPE2, CAT2), 
//memlocation(PFID, PLOC, PTYPE, PCAT), 
points_to(PFID, PLOC, PTYPE, PCAT, FID1, LOC1, TYPE1, CAT1), 
points_to(PFID, PLOC, PTYPE, PCAT, FID2, LOC2, TYPE2, CAT2).

//case load pointer
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :-
memlocation(FID1, LOC1, TYPE1, CAT1), 
memlocation(FID2, LOC2, TYPE2, CAT2),
instruction(BID, IID, VREG, OPC), block(FID, BID, _), OPC = "load",
pointer_level(TYPE1, TYPE1_PLVL),
pointer_level(TYPE2, TYPE2_PLVL),
TYPE1_PLVL = TYPE2_PLVL,
TYPE1_PLVL > 0,
VREG = LOC1,
FID1 = FID,
FID2 = FID, 
get_third_operand(IID, LOADADDR), 
LOADADDR = LOC2.

//case store a pointer
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :- 
block(FID, BID, _),
instruction(BID, IID, _, OPC), OPC = "store",
get_second_operand(IID, LOC2),
get_fourth_operand(IID, LOC1),
memlocation(FID1, LOC1, TYPE1, CAT1), memlocation(FID2, LOC2, TYPE2, CAT2),
pointer_level(TYPE1, TYPE1_PLVL),
pointer_level(TYPE2, TYPE2_PLVL),
TYPE1_PLVL = TYPE2_PLVL,
FID1 = FID,
FID2 = FID.


//case conversion instruction
memequals(FID1, LOC1, TYPE1, CAT1, FID2, LOC2, TYPE2, CAT2) :-
memlocation(FID1, LOC1, TYPE1, CAT1), 
memlocation(FID2, LOC2, TYPE2, CAT2),
instruction(BID, IID, VREG, _), block(FID, BID, _), 
is_conversion_instruction(IID),
get_first_operand(IID, VREG_ORIG),
LOC1 = VREG,
LOC2 = VREG_ORIG,
FID1 = FID,
FID2 = FID.

//points-to analysis
.decl points_to(functionid1: _functionid, memlocation1: symbol, memtyp1: symbol, memcategory1: _memcategory, 
functionid2: _functionid, memlocation2: symbol, memtyp2: symbol, memcategory2: _memcategory)
//.output points_to(delimiter=",")

//memequals cases
//cases memequals: (s -> e && as <==> s) ==> as -> e
points_to(SFID, SLOC, STYPE, SCAT, EFID, ELOC, ETYPE, ECAT) :- 
memlocation(SFID, SLOC, STYPE, SCAT), 
memlocation(EFID, ELOC, ETYPE, ECAT), 
memequals(SFID, SLOC, STYPE, SCAT, S2FID, S2LOC, S2TYPE, S2CAT), 
points_to(S2FID, S2LOC, S2TYPE, S2CAT, EFID, ELOC, ETYPE, ECAT).
//cases memequals: (s -> e && ae <==> e) ==> s -> ae
points_to(SFID, SLOC, STYPE, SCAT, EFID, ELOC, ETYPE, ECAT) :- 
memlocation(SFID, SLOC, STYPE, SCAT), 
memlocation(EFID, ELOC, ETYPE, ECAT), 
memequals(EFID, ELOC, ETYPE, ECAT, E2FID, E2LOC, E2TYPE, E2CAT), 
points_to(SFID, SLOC, STYPE, SCAT, E2FID, E2LOC, E2TYPE, E2CAT).
//case memequals: (s -> e && as <==> s && ae <==> e) ==> as -> ae
points_to(SFID, SLOC, STYPE, SCAT, EFID, ELOC, ETYPE, ECAT) :- 
memlocation(SFID, SLOC, STYPE, SCAT), 
memlocation(EFID, ELOC, ETYPE, ECAT),
memequals(SFID, SLOC, STYPE, SCAT, S2FID, S2LOC, S2TYPE, S2CAT), 
memequals(EFID, ELOC, ETYPE, ECAT, E2FID, E2LOC, E2TYPE, E2CAT), 
points_to(S2FID, S2LOC, S2TYPE, S2CAT, E2FID, E2LOC, E2TYPE, E2CAT).


//case store address to integer
points_to(SFID, SLOC, STYPE, SCAT, EFID, ELOC, ETYPE, ECAT) :- 
block(FID, BID, _),
instruction(BID, IID, _, OPC), OPC = "store",
get_second_operand(IID, ELOC),
get_fourth_operand(IID, SLOC),
pointer_level(STYPE, STYPE_PLVL),
memlocation(SFID, SLOC, STYPE, SCAT), memlocation(EFID, ELOC, ETYPE, ECAT),
pointer_level(ETYPE, ETYPE_PLVL),
ETYPE_PLVL < STYPE_PLVL,
ETYPE != "unknown", //TODO: fix parser to include types
SFID = FID,
EFID = FID.

//case load 
points_to(SFID, SLOC, STYPE, SCAT, EFID, ELOC, ETYPE, ECAT) :-
memlocation(SFID, SLOC, STYPE, SCAT), 
memlocation(EFID, ELOC, ETYPE, ECAT),
instruction(BID, IID, VREG, OPC), block(FID, BID, _), OPC = "load",
pointer_level(STYPE, STYPE_PLVL),
pointer_level(ETYPE, ETYPE_PLVL),
ETYPE_PLVL < STYPE_PLVL,
ETYPE_PLVL >= 1,
VREG = ELOC, 
get_third_operand(IID, SLOC), 
SFID = FID,
EFID = FID.


.decl get_val_of_load(instructionid: _instructionid, value: symbol)
get_val_of_load(IID, VAL) :- instruction(BID, IID, VREG, OPC), block(FID, BID, _), OPC = "load",
get_first_operand(IID, LOADTYPE), !is_pointer(LOADTYPE),
points_to(FID, VREG, _, _, FID, VAL, _, _).

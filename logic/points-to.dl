//points-to analysis
.decl points_to(functionid1: _functionid, memlocation1: symbol,
functionid2: _functionid, memlocation2: symbol)
//.output points_to(delimiter=",")

//memequals cases (not strictly necessary?)
//cases memequals: (s -> e && as <==> s) ==> as -> e
points_to(SFID, SLOC, EFID, ELOC) :- 
memequals(SFID, SLOC, S2FID, S2LOC), 
points_to(S2FID, S2LOC, EFID, ELOC).

//cases memequals: (s -> e && ae <==> e) ==> s -> ae
points_to(SFID, SLOC, EFID, ELOC) :- 
memequals(EFID, ELOC, E2FID, E2LOC), 
points_to(SFID, SLOC, E2FID, E2LOC).

/*
//case memequals: (s -> e && as <==> s && ae <==> e) ==> as -> ae
points_to(SFID, SLOC, EFID, ELOC) :- 
memequals(SFID, SLOC, S2FID, S2LOC), 
points_to(S2FID, S2LOC, E2FID, E2LOC),
memequals(EFID, ELOC, E2FID, E2LOC) 
.
*/


//case store address to integer
points_to(SFID, SLOC, EFID, ELOC) :- 
block(FID, BID, _),
instruction(BID, IID, _, OPC), OPC = "store",
get_second_operand(IID, ELOC),
get_fourth_operand(IID, SLOC),
pointer_level(STYPE, STYPE_PLVL),
memlocation(SFID, SLOC, STYPE, _), 
memlocation(EFID, ELOC, ETYPE, _),
pointer_level(ETYPE, ETYPE_PLVL),
ETYPE_PLVL < STYPE_PLVL,
ETYPE != "unknown", //TODO: fix parser to include types
SFID = FID,
EFID = FID.

//case load 
points_to(SFID, SLOC, EFID, ELOC) :-
memlocation(SFID, SLOC, STYPE, _), 
memlocation(EFID, ELOC, ETYPE, _),
instruction(BID, IID, VREG, OPC), block(FID, BID, _), OPC = "load",
pointer_level(STYPE, STYPE_PLVL),
pointer_level(ETYPE, ETYPE_PLVL),
ETYPE_PLVL < STYPE_PLVL,
ETYPE_PLVL >= 1,
VREG = ELOC, 
get_third_operand(IID, SLOC), 
SFID = FID,
EFID = FID.
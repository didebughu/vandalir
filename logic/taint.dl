//user input "tainting":

//function arguments containing userinput

//mode equal
memlocation(FID, LOC, TYPE, CAT) :- 
argument(FID, ARGID, LOC, TYPE), 
CAT = "userinput",
get_relative_argid(FID, ARGID, ARGID_REL),
function(FID, FNAME, _, _),
userinput(FNAME, ARGID_REL, "=", _)
.

//mode following
memlocation(FID, LOC, TYPE, CAT) :- 
argument(FID, ARGID, LOC, TYPE), 
CAT = "userinput",
get_relative_argid(FID, ARGID, ARGID_REL),
function(FID, FNAME, _, _),
userinput(FNAME, INPUT_ID, "+", _),
ARGID_REL >= INPUT_ID 
.

//TODO: add return value as userinput


// load instruction
memlocation(FID, LOC, TYPE, CAT) :- 
instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC = "load",
VREG != "%-1",
LOC = VREG,
CAT = "userinput",
get_first_operand(IID, TYPE),
//ensure it does contain user input:
get_third_operand(IID, LOADEDLOC),
is_memloc_with_userinput(FID, LOADEDLOC).

// getelementptr instruction
memlocation(FID, LOC, TYPE, CAT) :- 
instruction(BID, IID, VREG, OPC), block(FID, BID, _),
OPC = "getelementptr",
LOC = VREG,
CAT = "userinput",
TYPE = "unknown",
//ensure it does contain user input:
get_first_operand(IID, DATAOBJ),
is_memloc_with_userinput(FID, DATAOBJ)
.

/*
.decl userinput_memlocation(functionid: _functionid, location: symbol, type: symbol, limit: number)
userinput_memlocation(FID, LOC, TYPE, LIMIT) :-
memlocation(FID, LOC, TYPE, "userinput"),
block(FID, BID, _),
instruction(BID, IID, VREG, OPC),
*/



//determine if memlocation may contain userinput
.decl is_memloc_with_userinput(functionid: _functionid, location: symbol)
is_memloc_with_userinput(FID, LOC) :- 
memlocation(FID, LOC, _, "userinput").

is_memloc_with_userinput(FID, LOC) :- 
memequals(FID, LOC, FID2, LOC2),
memlocation(FID2, LOC2, _, "userinput")
.
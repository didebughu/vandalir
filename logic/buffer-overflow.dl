//get size of heap allocation
.decl get_size_of_heap_alloc(instructionid: _instructionid, size: number)
get_size_of_heap_alloc(IID, SIZE) :- is_heap_allocation_call(IID), is_malloc_call_instruction(IID), get_size_of_malloc(IID, SIZE).
get_size_of_heap_alloc(IID, SIZE) :- is_heap_allocation_call(IID), is_calloc_call_instruction(IID), get_size_of_calloc(IID, SIZE).
get_size_of_heap_alloc(IID, SIZE) :- is_heap_allocation_call(IID), is_realloc_call_instruction(IID), get_size_of_realloc(IID, SIZE).


//get size of malloc
.decl get_size_of_malloc(instructionid: _instructionid, size: number)
//case hard coded size
get_size_of_malloc(IID, SIZE) :- is_malloc_call_instruction(IID),
get_first_operand(IID, OV1),
is_numeric(OV1),
SIZE = to_number(OV1).
//case get size by vreg
get_size_of_malloc(IID, SIZE) :- is_malloc_call_instruction(IID),
get_first_operand(IID, OV1),
block(FID, BID, _), instruction(BID, IID, _, _),
is_vreg(OV1),
get_int_by_vreg(SIZE, FID, OV1).

//get size of calloc
//case both hardcoaded
.decl get_size_of_calloc(instructionid: _instructionid, size: number)
get_size_of_calloc(IID, SIZE) :- is_calloc_call_instruction(IID),
get_first_operand(IID, OV1), get_second_operand(IID, OV2),
is_numeric(OV1), is_numeric(OV2),
SIZE = to_number(OV1)*to_number(OV2).
//case vreg, hardcoded
get_size_of_calloc(IID, SIZE) :- is_calloc_call_instruction(IID),
get_first_operand(IID, OV1), get_second_operand(IID, OV2),
block(FID, BID, _), instruction(BID, IID, _, _),
get_int_by_vreg(SIZE1, FID, OV1),
is_vreg(OV1), is_numeric(OV2),
SIZE2 = to_number(OV2), 
SIZE = SIZE1*SIZE2.
//case hardcoded, vreg
get_size_of_calloc(IID, SIZE) :- is_calloc_call_instruction(IID),
get_first_operand(IID, OV1), get_second_operand(IID, OV2),
block(FID, BID, _), instruction(BID, IID, _, _),
get_int_by_vreg(SIZE2, FID, OV2),
is_numeric(OV1), is_vreg(OV2),
SIZE1 = to_number(OV1),
SIZE = SIZE1*SIZE2.
//case both hardcoded
get_size_of_calloc(IID, SIZE) :- is_calloc_call_instruction(IID),
get_first_operand(IID, OV1), get_second_operand(IID, OV2),
block(FID, BID, _), instruction(BID, IID, _, _),
get_int_by_vreg(SIZE1, FID, OV1),
get_int_by_vreg(SIZE2, FID, OV2),
is_vreg(OV1), is_vreg(OV2),
SIZE = SIZE1*SIZE2.

//get size of realloc
//case hard coded size
.decl get_size_of_realloc(instructionid: _instructionid, size: number)
get_size_of_realloc(IID, SIZE) :- is_realloc_call_instruction(IID),
get_second_operand(IID, OV2), 
is_numeric(OV2),
SIZE = to_number(OV2).
//case get size by vreg
get_size_of_realloc(IID, SIZE) :- is_realloc_call_instruction(IID),
get_second_operand(IID, OV2), 
is_vreg(OV2),
block(FID, BID, _), instruction(BID, IID, _, _),
get_int_by_vreg(SIZE, FID, OV2).



//get size of buffer by virtual register
.decl get_buffsize_by_vreg(size: number, functionid: _functionid, _vreg: symbol)
//.output get_buffsize_by_vreg(delimiter=",")
//case alloca (end recursion)
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "alloca",
get_size_of_alloca(IID, VAL), get_second_operand(IID, ALLOCATYPE),
!is_pointer(ALLOCATYPE).

//case getelementptr
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "getelementptr", 
get_first_operand(IID, OV1), get_buffsize_by_vreg(VAL, FID, OV1).

//case memequals
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, _, VREG, _),
memequals(FID, START_LOC, _, _, END_FID, END_LOC, _, _), 
START_LOC = VREG,
get_buffsize_by_vreg(VAL, END_FID, END_LOC).

//case heap allocation
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, _), 
is_heap_allocation_call(IID), get_size_of_heap_alloc(IID, SIZE),
VAL = SIZE.


//actual implementation of get possible integer values
.decl get_int_by_vreg(value: number, functionid: _functionid, _vreg: symbol)
//.output get_int_by_vreg(delimiter=",")
//case add
get_int_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "add",
get_first_operand(IID, OV1), get_third_operand(IID, OV2), 
VAL=TMP+to_number(OV2), get_int_by_vreg(TMP, FID, OV1).

//case sub
get_int_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "sub",
get_first_operand(IID, OV1), get_third_operand(IID, OV2), 
VAL=TMP-to_number(OV2), get_int_by_vreg(TMP, FID, OV1).

//case call strlen
get_int_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "call",
get_first_operand(IID, OV1), is_strlen_call_instruction(IID),
get_buffsize_by_vreg(VAL, FID, OV1).

//case memequals
get_int_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, _, VREG, _),
memequals(FID, START_LOC, _, _, FID, END_LOC, _, _), 
START_LOC = VREG,
get_int_by_vreg(VAL, FID, END_LOC).


//TODO: case load integer
//TODO: case store integer ?


//strncpy vulnerable to bo
.decl is_vulnerable_strncpy_call_instruction(instructionid: _instructionid)
//computed n
is_vulnerable_strncpy_call_instruction(IID) :- is_strncpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, OV1), get_third_operand(IID, N), 
get_buffsize_by_vreg(DEST_SIZE, FID, OV1), is_vreg(N), 
get_int_by_vreg(COPY_SIZE, FID, N),
DEST_SIZE < COPY_SIZE.
//hardcoded n
is_vulnerable_strncpy_call_instruction(IID) :- is_strncpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, OV1), get_third_operand(IID, N),  
get_buffsize_by_vreg(DEST_SIZE, FID, OV1), 
is_numeric(N),
DEST_SIZE < to_number(N).

//fgets vulnerable to bo
.decl is_vulnerable_fgets_call_instruction(instructionid: _instructionid)
//computed n
is_vulnerable_fgets_call_instruction(IID) :- is_fgets_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, OV1), get_second_operand(IID, N), 
get_int_by_vreg(DEST_SIZE, FID, OV1), is_vreg(N), 
get_buffsize_by_vreg(COPY_SIZE, FID, N),
DEST_SIZE < COPY_SIZE.
//hardcoded n
is_vulnerable_fgets_call_instruction(IID) :- is_fgets_call_instruction(IID),
block(FID, BID, _), instruction(BID, IID, _, _), 
get_first_operand(IID, OV1), get_second_operand(IID, N),
get_buffsize_by_vreg(DEST_SIZE, FID, OV1), 
is_numeric(N),
DEST_SIZE < to_number(N).

//print results
.decl print_vulnerable(functionname: symbol, label: symbol, virtualregister: symbol, opcode: symbol)
.output print_vulnerable(delimiter=",")
print_vulnerable(NAME, LAB, VREG, FNAME) :- instruction(BID, IID, VREG, _), 
get_function_for_call_instruction(FNAME, IID),
is_vulnerable_strncpy_call_instruction(IID), block(FID, BID, LAB), function(FID, NAME, _, _).

print_vulnerable(NAME, LAB, VREG, FNAME) :- instruction(BID, IID, VREG, _),
get_function_for_call_instruction(FNAME, IID), 
is_vulnerable_fgets_call_instruction(IID), block(FID, BID, LAB), function(FID, NAME, _, _).
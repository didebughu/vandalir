//get size of buffer by virtual register
.decl get_buffsize_by_vreg(size: number, functionid: _functionid, _vreg: symbol)
//.output get_buffsize_by_vreg(delimiter=",")

//case alloca (end recursion)
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "alloca",
get_size_of_alloca(IID, VAL).

//case call strlen
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "call",
get_first_operand(IID, OV1), is_strlen_call_instruction(IID),
get_buffsize_by_vreg(VAL, FID, OV1).

//case getelementptr
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "getelementptr", 
get_first_operand(IID, OV1), get_buffsize_by_vreg(VAL, FID, OV1).

//case add
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "add",
get_first_operand(IID, OV1), get_second_operand(IID, OV2), 
VAL=TMP+to_number(OV2), get_buffsize_by_vreg(TMP, FID, OV1).

//case sub
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "sub",
get_first_operand(IID, OV1), get_second_operand(IID, OV2), 
VAL=TMP-to_number(OV2), get_buffsize_by_vreg(TMP, FID, OV1).

//case trunc
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "trunc",
get_first_operand(IID, OV1),
get_buffsize_by_vreg(VAL, FID, OV1).

//case load
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, OPC), OPC = "load",
get_first_operand(IID, TYPE), get_third_operand(IID, LOADREG),
contains("*", TYPE), //load pointer
points_to(START, END), START = [FID, START_LOC, _], 
END = [FID, END_LOC, _], 
START_LOC = LOADREG,
get_buffsize_by_vreg(VAL, FID, END_LOC).

//case malloc
get_buffsize_by_vreg(VAL, FID, VREG) :- block(FID, BID, _), instruction(BID, IID, VREG, _), 
is_malloc_call_instruction(IID), get_size_of_malloc(IID, SIZE),
VAL = SIZE.

//if call instruction give called function name
.decl get_function_for_call_instruction(function: symbol, instructionid: _instructionid, blockid: _blockid)
//case not a call instruction
get_function_for_call_instruction(OPC, IID, BID) :- instruction(BID, IID, _, OPC), OPC != "call".
//a call instruction
get_function_for_call_instruction(NAME, IID, BID) :- instruction(BID, IID, _, OPC), OPC = "call",
MAXID = max OID : {operand(IID, OID, _) }, operand(IID, MAXID, NAME).


//strncpy vulnerable to bo
.decl is_vulnerable_strncpy_call_instruction(instructionid: _instructionid)
//computed n
is_vulnerable_strncpy_call_instruction(IID) :- is_strncpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, OV1), get_third_operand(IID, N), 
get_buffsize_by_vreg(DEST_SIZE, FID, OV1), contains("%", N), 
get_buffsize_by_vreg(COPY_SIZE, FID, N),
DEST_SIZE < COPY_SIZE.
//hardcoded n
is_vulnerable_strncpy_call_instruction(IID) :- is_strncpy_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, OV1), get_third_operand(IID, N),  
get_buffsize_by_vreg(DEST_SIZE, FID, OV1), 
!contains("%", N),
DEST_SIZE < to_number(N).

//fgets vulnerable to bo
.decl is_vulnerable_fgets_call_instruction(instructionid: _instructionid)
//computed n
is_vulnerable_fgets_call_instruction(IID) :- is_fgets_call_instruction(IID), 
block(FID, BID, _), instruction(BID, IID, _, _),
get_first_operand(IID, OV1), get_second_operand(IID, N), 
get_buffsize_by_vreg(DEST_SIZE, FID, OV1), contains("%", N), 
get_buffsize_by_vreg(COPY_SIZE, FID, N),
DEST_SIZE < COPY_SIZE.
//hardcoded n
is_vulnerable_fgets_call_instruction(IID) :- is_fgets_call_instruction(IID), 
get_first_operand(IID, OV1), get_second_operand(IID, N),
get_buffsize_by_vreg(DEST_SIZE, FID, OV1), 
!contains("%", N),
DEST_SIZE < to_number(N).

//print results
.decl print_vulnerable(functionname: symbol, label: symbol, virtualregister: symbol, opcode: symbol)
.output print_vulnerable(delimiter=",")
print_vulnerable(NAME, LAB, VREG, OUT) :- instruction(BID, IID, VREG, _), 
get_function_for_call_instruction(OUT, IID, BID),
is_vulnerable_strncpy_call_instruction(IID), block(FID, BID, LAB), function(FID, NAME, _, _).

print_vulnerable(NAME, LAB, VREG, OUT) :- instruction(BID, IID, VREG, _),
get_function_for_call_instruction(OUT, IID, BID), 
is_vulnerable_fgets_call_instruction(IID), block(FID, BID, LAB), function(FID, NAME, _, _).
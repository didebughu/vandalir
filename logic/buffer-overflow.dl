//get size of buffer by virtual register
.decl get_size_by_vreg(size: number, blockid: number, virtualregister: symbol)
//case alloca (end recursion)
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "alloca",
get_size_of_alloca(VAL, IID).
//case call strlen
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "call",
operand(IID, OID1, OV1), operand(IID, OID2, _), 
OID2 = OID1+1, is_strlen_call_instruction(IID, BID),
get_size_by_vreg(VAL, BID, OV1).
//case getelementptr
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "getelementptr", 
operand(IID, OID1, OV1), operand(IID, OID2, _), operand(IID, OID3, _),
OID2 = OID1+1, OID3 = OID2+1, get_size_by_vreg(VAL, BID, OV1).
//case add
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "add",
operand(IID, OID1, OV1), operand(IID, OID2, OV2),
OID2 = OID1+1, VAL=TMP+to_number(OV2), get_size_by_vreg(TMP, BID, OV1).
//case sub
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "sub",
operand(IID, OID1, OV1), operand(IID, OID2, OV2),
OID2 = OID1+1, VAL=TMP-to_number(OV2), get_size_by_vreg(TMP, BID, OV1).
//case trunc
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "trunc",
operand(IID, _, OV1),
get_size_by_vreg(VAL, BID, OV1).
//case malloc
/*
get_size_by_vreg(VAL, BID, VREG) :- instruction(BID, IID, VREG, OPC), OPC = "call",
operand(IID, OID1, OV1), operand(IID, OID2, _), 
OID2 = OID1+1, is_malloc_call_instruction(IID, BID),
VAL = to_number(OV1).
*/
//case load
//points-to analysis

//if call instruction give called function name
.decl get_function_for_call_instruction(function: symbol, instructionid: number, blockid: number)
//case not a call instruction
get_function_for_call_instruction(OPC, IID, BID) :- instruction(BID, IID, _, OPC), OPC != "call".
//a call instruction
get_function_for_call_instruction(NAME, IID, BID) :- instruction(BID, IID, _, OPC), OPC = "call",
MAXID = max OID : {operand(IID, OID, _) }, operand(IID, MAXID, NAME).


//strncpy vulnerable to bo
.decl is_vulnerable_strncpy_call_instruction(instructionid: number, blockid: number)
//computed n
is_vulnerable_strncpy_call_instruction(IID, BID) :- is_strncpy_call_instruction(IID, BID), 
operand(IID, OID1, OV1), operand(IID, OID2, _), operand(IID, OID3, N), operand(IID, OID4, _), 
OID2 = OID1+1, OID3 = OID2+1, OID4 = OID3+1, 
get_size_by_vreg(DEST_SIZE, BID, OV1), contains("%", N), 
get_size_by_vreg(COPY_SIZE, BID, N),
DEST_SIZE < COPY_SIZE.
//hardcoded n
is_vulnerable_strncpy_call_instruction(IID, BID) :- is_strncpy_call_instruction(IID, BID), 
operand(IID, OID1, OV1), operand(IID, OID2, _), operand(IID, OID3, N), operand(IID, OID4, _), 
OID2 = OID1+1, OID3 = OID2+1, OID4 = OID3+1, 
get_size_by_vreg(DEST_SIZE, BID, OV1), 
!contains("%", N),
DEST_SIZE < to_number(N).

//fgets vulnerable to bo
.decl is_vulnerable_fgets_call_instruction(instructionid: number, blockid: number)
//computed n
is_vulnerable_fgets_call_instruction(IID, BID) :- is_fgets_call_instruction(IID, BID), 
operand(IID, OID1, OV1), operand(IID, OID2, N), operand(IID, OID3, _), operand(IID, OID4, _), 
OID2 = OID1+1, OID3 = OID2+1, OID4 = OID3+1, 
get_size_by_vreg(DEST_SIZE, BID, OV1), contains("%", N), 
get_size_by_vreg(COPY_SIZE, BID, N),
DEST_SIZE < COPY_SIZE.
//hardcoded n
is_vulnerable_fgets_call_instruction(IID, BID) :- is_fgets_call_instruction(IID, BID), 
operand(IID, OID1, OV1), operand(IID, OID2, N), operand(IID, OID3, _), operand(IID, OID4, _), 
OID2 = OID1+1, OID3 = OID2+1, OID4 = OID3+1, 
get_size_by_vreg(DEST_SIZE, BID, OV1), 
!contains("%", N),
DEST_SIZE < to_number(N).